[4.6/4.7 Regression] Wrong constant folding

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56899

--- gcc-4_8-branch/gcc/ChangeLog	2013/04/11 07:30:20	197692
+++ gcc-4_8-branch/gcc/ChangeLog	2013/04/11 07:37:17	197693
@@ -1,6 +1,12 @@
 
 	* GCC 4.7.3 released.
 
+2013-04-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/56899
+	* fold-const.c (extract_muldiv_1): Apply distributive law
+	only if TYPE_OVERFLOW_WRAPS (ctype).
+
 2013-04-10  David S. Miller  <davem@davemloft.net>
 
 	* config/sparc/sparc.h (ASM_CPU_SPEC): Pass -Av8 if -mcpu=supersparc
--- gcc-4_8-branch/gcc/fold-const.c	2013/04/11 07:30:20	197692
+++ gcc-4_8-branch/gcc/fold-const.c	2013/04/11 07:37:17	197693
@@ -5848,8 +5848,10 @@ extract_muldiv_1 (tree t, tree c, enum t
 
       /* The last case is if we are a multiply.  In that case, we can
 	 apply the distributive law to commute the multiply and addition
-	 if the multiplication of the constants doesn't overflow.  */
-      if (code == MULT_EXPR)
+	 if the multiplication of the constants doesn't overflow
+	 and overflow is defined.  With undefined overflow
+	 op0 * c might overflow, while (op0 + orig_op1) * c doesn't.  */
+      if (code == MULT_EXPR && TYPE_OVERFLOW_WRAPS (ctype))
 	return fold_build2 (tcode, ctype,
 			    fold_build2 (code, ctype,
 					 fold_convert (ctype, op0),
--- gcc-4_8-branch/gcc/testsuite/ChangeLog	2013/04/11 07:30:20	197692
+++ gcc-4_8-branch/gcc/testsuite/ChangeLog	2013/04/11 07:37:17	197693
@@ -1,6 +1,11 @@
 
 	* GCC 4.7.3 released.
 
+2013-04-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/56899
+	* gcc.c-torture/execute/pr56899.c: New test.
+
 2013-04-03  Jakub Jelinek  <jakub@redhat.com>
 
 	PR debug/56819
--- /dev/null
+++ gcc-4_8-branch/gcc/testsuite/gcc.c-torture/execute/pr56899.c	2013/04/11 07:37:17	197693
@@ -0,0 +1,47 @@
+/* PR tree-optimization/56899 */
+
+#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+__attribute__((noinline, noclone)) void
+f1 (int v)
+{
+  int x = -214748365 * (v - 1);
+  if (x != -1932735285)
+    __builtin_abort ();
+}
+
+__attribute__((noinline, noclone)) void
+f2 (int v)
+{
+  int x = 214748365 * (v + 1);
+  if (x != -1932735285)
+    __builtin_abort ();
+}
+
+__attribute__((noinline, noclone)) void
+f3 (unsigned int v)
+{
+  unsigned int x = -214748365U * (v - 1);
+  if (x != -1932735285U)
+    __builtin_abort ();
+}
+
+__attribute__((noinline, noclone)) void
+f4 (unsigned int v)
+{
+  unsigned int x = 214748365U * (v + 1);
+  if (x != -1932735285U)
+    __builtin_abort ();
+}
+#endif
+
+int
+main ()
+{
+#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+  f1 (10);
+  f2 (-10);
+  f3 (10);
+  f4 (-10U);
+#endif
+  return 0;
+}
