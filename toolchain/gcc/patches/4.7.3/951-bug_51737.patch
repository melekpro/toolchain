[4.6 Regression] g++ crashes (internal compiler error: Segmentation fault) when compiling quickbook

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51737

--- trunk/gcc/ChangeLog	2012/03/22 13:52:19	185693
+++ trunk/gcc/ChangeLog	2012/03/22 14:33:27	185694
@@ -1,6 +1,16 @@
 	* config/epiphany/epiphany.c (epiphany_function_value_regno_p):
 	Make static.
 
+2012-03-22  Jan Hubicka  <jh@suse.cz>
+
+	PR middle-end/51737
+	* cgraph.c (cgraph_remove_node_and_inline_clones): Add FORBIDDEN_NODE
+	parameter.
+	* cgraph.h (cgraph_remove_node_and_inline_clones): Update prototype.
+	* ipa-inline-transform.c (save_inline_function_body): Remove copied clone
+	if needed.
+	* tree-inline.c (delete_unreachable_blocks_update_callgraph): Update.
+
 2012-03-22  Kaz Kojima  <kkojima@gcc.gnu.org>
 
 	Backported from mainline
--- trunk/gcc/cgraph.c	2012/03/22 13:52:19	185693
+++ trunk/gcc/cgraph.c	2012/03/22 14:33:27	185694
@@ -1639,19 +1639,27 @@
     }
 }
 
-/* Remove the node from cgraph.  */
+/* Remove the node from cgraph and all inline clones inlined into it.
+   Skip however removal of FORBIDDEN_NODE and return true if it needs to be
+   removed.  This allows to call the function from outer loop walking clone
+   tree.  */
 
-void
-cgraph_remove_node_and_inline_clones (struct cgraph_node *node)
+bool
+cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_node *forbidden_node)
 {
   struct cgraph_edge *e, *next;
+  bool found = false;
+
+  if (node == forbidden_node)
+    return true;
   for (e = node->callees; e; e = next)
     {
       next = e->next_callee;
       if (!e->inline_failed)
-        cgraph_remove_node_and_inline_clones (e->callee);
+        found |= cgraph_remove_node_and_inline_clones (e->callee, forbidden_node);
     }
   cgraph_remove_node (node);
+  return found;
 }
 
 /* Notify finalize_compilation_unit that given node is reachable.  */
--- trunk/gcc/cgraph.h	2012/03/22 13:52:19	185693
+++ trunk/gcc/cgraph.h	2012/03/22 14:33:27	185694
@@ -478,7 +478,7 @@
 void cgraph_remove_edge (struct cgraph_edge *);
 void cgraph_remove_node (struct cgraph_node *);
 void cgraph_add_to_same_comdat_group (struct cgraph_node *, struct cgraph_node *);
-void cgraph_remove_node_and_inline_clones (struct cgraph_node *);
+bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);
 void cgraph_release_function_body (struct cgraph_node *);
 void cgraph_node_remove_callees (struct cgraph_node *node);
 struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,
--- trunk/gcc/ipa-inline-transform.c	2012/03/22 13:52:19	185693
+++ trunk/gcc/ipa-inline-transform.c	2012/03/22 14:33:27	185694
@@ -336,8 +336,19 @@
             first_clone->ipa_transforms_to_apply);
   first_clone->ipa_transforms_to_apply = NULL;
 
+  /* When doing recursive inlining, the clone may become unnecessary.
+     This is possible i.e. in the case when the recursive function is proved to be
+     non-throwing and the recursion happens only in the EH landing pad.
+     We can not remove the clone until we are done with saving the body.
+     Remove it now.  */
+  if (!first_clone->callers)
+    {
+      cgraph_remove_node_and_inline_clones (first_clone, NULL);
+      first_clone = NULL;
+    }
 #ifdef ENABLE_CHECKING
-  verify_cgraph_node (first_clone);
+  else
+    verify_cgraph_node (first_clone);
 #endif
   return first_clone;
 }
--- trunk/gcc/testsuite/ChangeLog	2012/03/22 13:52:19	185693
+++ trunk/gcc/testsuite/ChangeLog	2012/03/22 14:33:27	185694
@@ -1,6 +1,11 @@
 	PR middle-end/52640
 	* gcc.c-torture/compile/limits-externdecl.c: New test.
 
+2012-03-22  Jan Hubicka  <jh@suse.cz>
+
+	PR middle-end/51737
+	* g++.dg/torture/pr51737.C: New testcase
+
 2012-03-22  Paolo Carlini  <paolo.carlini@oracle.com>
 
 	PR c++/52487
--- trunk/gcc/tree-inline.c	2012/03/22 13:52:19	185693
+++ trunk/gcc/tree-inline.c	2012/03/22 14:33:27	185694
@@ -4955,7 +4955,7 @@
 	        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)
 		  {
 		    if (!e->inline_failed)
-		      cgraph_remove_node_and_inline_clones (e->callee);
+		      cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);
 		    else
 	              cgraph_remove_edge (e);
 		  }
@@ -4966,7 +4966,7 @@
 	              if ((e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)
 			{
 		          if (!e->inline_failed)
-		            cgraph_remove_node_and_inline_clones (e->callee);
+		            cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);
 			  else
 	                    cgraph_remove_edge (e);
 			}
