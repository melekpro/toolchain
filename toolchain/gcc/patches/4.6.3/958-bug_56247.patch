[4.6/4.7/4.8 Regression] internal compiler error: in tsubst_copy, at cp/pt.c:12131

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56247

--- gcc-4_6-branch/gcc/testsuite/g++.dg/template/ptrmem23.C	(revision 0)
+++ gcc-4_6-branch/gcc/testsuite/g++.dg/template/ptrmem23.C	(revision 195924)
@@ -0,0 +1,22 @@
+// PR c++/56247
+
+struct Base {
+    void method() {}
+};
+
+typedef void (Base::*MemPtr)();
+
+// Template with a member function pointer "non-type parameter".
+template<MemPtr func>
+struct Wrapper {};
+
+template<class C>
+struct Child : public Base {
+    // Templated derived class instantiates the Wrapper with the same parameter
+    // in two different virtual methods.
+    void foo() { typedef Wrapper<&Base::method> W; }
+    void bar() { typedef Wrapper<&Base::method> W; }
+};
+
+// Instantiate Child with some type.
+template class Child<int>;
--- gcc-4_6-branch/gcc/cp/tree.c	(revision 195923)
+++ gcc-4_6-branch/gcc/cp/tree.c	(revision 195924)
@@ -2245,6 +2245,13 @@
 	 with an out-of-class definition of the function, but can also come
 	 up for expressions that involve 'this' in a member function
 	 template.  */
+
+      if (comparing_specializations)
+	/* When comparing hash table entries, only an exact match is
+	   good enough; we don't want to replace 'this' with the
+	   version from another function.  */
+	return false;
+
       if (same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))
 	{
 	  if (DECL_ARTIFICIAL (t1) ^ DECL_ARTIFICIAL (t2))
--- gcc-4_6-branch/gcc/cp/ChangeLog	(revision 195923)
+++ gcc-4_6-branch/gcc/cp/ChangeLog	(revision 195924)
@@ -1,3 +1,10 @@
+2013-02-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/56247
+	* pt.c (eq_specializations): Set comparing_specializations.
+	* tree.c (cp_tree_equal): Check it.
+	* cp-tree.h: Declare it.
+
 2012-12-06  Jason Merrill  <jason@redhat.com>
 
 	PR c++/55249
--- gcc-4_6-branch/gcc/cp/pt.c	(revision 195923)
+++ gcc-4_6-branch/gcc/cp/pt.c	(revision 195924)
@@ -1432,14 +1432,21 @@
 /* Returns true iff two spec_entry nodes are equivalent.  Only compares the
    TMPL and ARGS members, ignores SPEC.  */
 
+int comparing_specializations;
+
 static int
 eq_specializations (const void *p1, const void *p2)
 {
   const spec_entry *e1 = (const spec_entry *)p1;
   const spec_entry *e2 = (const spec_entry *)p2;
+  int equal;
 
-  return (e1->tmpl == e2->tmpl
-	  && comp_template_args (e1->args, e2->args));
+  ++comparing_specializations;
+  equal = (e1->tmpl == e2->tmpl
+	   && comp_template_args (e1->args, e2->args));
+  --comparing_specializations;
+
+  return equal;
 }
 
 /* Returns a hash for a template TMPL and template arguments ARGS.  */
--- gcc-4_6-branch/gcc/cp/cp-tree.h	(revision 195923)
+++ gcc-4_6-branch/gcc/cp/cp-tree.h	(revision 195924)
@@ -4022,6 +4022,10 @@
    function, two inside the body of a function in a local class, etc.)  */
 extern int function_depth;
 
+/* Nonzero if we are inside eq_specializations, which affects comparison of
+   PARM_DECLs in cp_tree_equal.  */
+extern int comparing_specializations;
+
 /* In parser.c.  */
 
 /* Nonzero if we are parsing an unevaluated operand: an operand to
