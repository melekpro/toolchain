Index: gcc/doc/tm.texi
===================================================================
--- gcc-4_6-branch/gcc/doc/tm.texi	(revision 190295)
+++ gcc-4_6-branch/gcc/doc/tm.texi	(revision 190296)
@@ -1118,6 +1118,14 @@
 If the value of this macro has a type, it should be an unsigned type.
 @end defmac
 
+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_VECTOR_ALIGNMENT (const_tree @var{type})
+This hook can be used to define the alignment for a vector of type
+@var{type}, in order to comply with a platform ABI.  The default is to
+require natural alignment for vector types.  The alignment returned by
+this hook must be a power-of-two multiple of the default alignment of
+the vector element type.
+@end deftypefn
+
 @defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})
 If defined, a C expression to compute the alignment for stack slot.
 @var{type} is the data type, @var{mode} is the widest mode available,
Index: gcc/doc/tm.texi.in
===================================================================
--- gcc-4_6-branch/gcc/doc/tm.texi.in	(revision 190295)
+++ gcc-4_6-branch/gcc/doc/tm.texi.in	(revision 190296)
@@ -1108,6 +1108,8 @@
 If the value of this macro has a type, it should be an unsigned type.
 @end defmac
 
+@hook TARGET_VECTOR_ALIGNMENT
+
 @defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})
 If defined, a C expression to compute the alignment for stack slot.
 @var{type} is the data type, @var{mode} is the widest mode available,
Index: gcc/targhooks.c
===================================================================
--- gcc-4_6-branch/gcc/targhooks.c	(revision 190295)
+++ gcc-4_6-branch/gcc/targhooks.c	(revision 190296)
@@ -979,6 +979,13 @@
    return id;
 }
 
+/* Default to natural alignment for vector types.  */
+HOST_WIDE_INT
+default_vector_alignment (const_tree type)
+{
+  return tree_low_cst (TYPE_SIZE (type), 0);
+}
+
 bool
 default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)
 {
Index: gcc/targhooks.h
===================================================================
--- gcc-4_6-branch/gcc/targhooks.h	(revision 190295)
+++ gcc-4_6-branch/gcc/targhooks.h	(revision 190296)
@@ -85,6 +85,8 @@
 
 extern tree default_builtin_reciprocal (unsigned int, bool, bool);
 
+extern HOST_WIDE_INT default_vector_alignment (const_tree);
+
 extern bool default_builtin_vector_alignment_reachable (const_tree, bool);
 extern bool
 default_builtin_support_vector_misalignment (enum machine_mode mode,
Index: gcc/target.def
===================================================================
--- gcc-4_6-branch/gcc/target.def	(revision 190295)
+++ gcc-4_6-branch/gcc/target.def	(revision 190296)
@@ -1611,6 +1611,16 @@
  bool, (enum machine_mode mode),
  hook_bool_mode_false)
 
+DEFHOOK
+(vector_alignment,
+ "This hook can be used to define the alignment for a vector of type\n\
+@var{type}, in order to comply with a platform ABI.  The default is to\n\
+require natural alignment for vector types.  The alignment returned by\n\
+this hook must be a power-of-two multiple of the default alignment of\n\
+the vector element type.",
+ HOST_WIDE_INT, (const_tree type),
+ default_vector_alignment)
+
 /* Compute cost of moving data from a register of class FROM to one of
    TO, using MODE.  */
 DEFHOOK
Index: gcc/ChangeLog
===================================================================
--- gcc-4_6-branch/gcc/ChangeLog	(revision 190295)
+++ gcc-4_6-branch/gcc/ChangeLog	(revision 190296)
@@ -1,3 +1,24 @@
+2012-08-10  Ulrich Weigand  <ulrich.weigand@linaro.org>
+
+	Backport from mainline
+	2012-07-30  Ulrich Weigand  <ulrich.weigand@linaro.org>
+		    Richard Earnshaw  <rearnsha@arm.com>
+
+	* target.def (vector_alignment): New target hook.
+	* doc/tm.texi.in (TARGET_VECTOR_ALIGNMENT): Document new hook.
+	* doc/tm.texi: Regenerate.
+	* targhooks.c (default_vector_alignment): New function.
+	* targhooks.h (default_vector_alignment): Add prototype.
+	* stor-layout.c (layout_type): Use targetm.vector_alignment.
+	* config/arm/arm.c (arm_vector_alignment): New function.
+	(TARGET_VECTOR_ALIGNMENT): Define.
+
+	* tree-vect-data-refs.c (vect_update_misalignment_for_peel): Use
+	vector type alignment instead of size.
+	* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound): Use
+	element type size directly instead of computing it from alignment.
+	Fix variable naming and comment.
+
 2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>
 
 	Backported from trunk:
Index: gcc/tree-vect-loop-manip.c
===================================================================
--- gcc-4_6-branch/gcc/tree-vect-loop-manip.c	(revision 190295)
+++ gcc-4_6-branch/gcc/tree-vect-loop-manip.c	(revision 190296)
@@ -2008,7 +2008,7 @@
    If the misalignment of DR is known at compile time:
      addr_mis = int mis = DR_MISALIGNMENT (dr);
    Else, compute address misalignment in bytes:
-     addr_mis = addr & (vectype_size - 1)
+     addr_mis = addr & (vectype_align - 1)
 
    prolog_niters = min (LOOP_NITERS, ((VF - addr_mis/elem_size)&(VF-1))/step)
 
@@ -2065,9 +2065,10 @@
       tree ptr_type = TREE_TYPE (start_addr);
       tree size = TYPE_SIZE (ptr_type);
       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);
-      tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);
-      tree elem_size_log =
-        build_int_cst (type, exact_log2 (vectype_align/nelements));
+      tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);
+      HOST_WIDE_INT elem_size =
+		int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));
+      tree elem_size_log = build_int_cst (type, exact_log2 (elem_size));
       tree nelements_minus_1 = build_int_cst (type, nelements - 1);
       tree nelements_tree = build_int_cst (type, nelements);
       tree byte_misalign;
@@ -2076,10 +2077,10 @@
       new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmts);
       gcc_assert (!new_bb);
 
-      /* Create:  byte_misalign = addr & (vectype_size - 1)  */
+      /* Create:  byte_misalign = addr & (vectype_align - 1)  */
       byte_misalign =
         fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), 
-                     vectype_size_minus_1);
+                     vectype_align_minus_1);
 
       /* Create:  elem_misalign = byte_misalign / element_size  */
       elem_misalign =
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- gcc-4_6-branch/gcc/testsuite/lib/target-supports.exp	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/lib/target-supports.exp	(revision 190296)
@@ -2976,6 +2976,26 @@
     return $et_natural_alignment_64_saved
 }
 
+# Return 1 if all vector types are naturally aligned (aligned to their
+# type-size), 0 otherwise.
+#
+# This won't change for different subtargets so cache the result.
+
+proc check_effective_target_vect_natural_alignment { } {
+    global et_vect_natural_alignment
+
+    if [info exists et_vect_natural_alignment_saved] {
+        verbose "check_effective_target_vect_natural_alignment: using cached result" 2
+    } else {
+        set et_vect_natural_alignment_saved 1
+        if { [check_effective_target_arm_eabi] } {
+            set et_vect_natural_alignment_saved 0
+        }
+    }
+    verbose "check_effective_target_vect_natural_alignment: returning $et_vect_natural_alignment_saved" 2
+    return $et_vect_natural_alignment_saved
+}
+
 # Return 1 if vector alignment (for types of size 32 bit or less) is reachable, 0 otherwise.
 #
 # This won't change for different subtargets so cache the result.
Index: gcc/testsuite/gcc.dg/align-2.c
===================================================================
--- gcc-4_6-branch/gcc/testsuite/gcc.dg/align-2.c	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/align-2.c	(revision 190296)
@@ -1,5 +1,5 @@
 /* PR 17962 */
-/* { dg-do compile } */
+/* { dg-do compile { target vect_natural_alignment } } */
 /* { dg-options "" } */
 
 typedef float v4 __attribute__((vector_size(sizeof(float)*4)));
Index: gcc/testsuite/gcc.dg/vect/vect-peel-1.c
===================================================================
--- gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-1.c	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-1.c	(revision 190296)
@@ -49,6 +49,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/vect-peel-2.c
===================================================================
--- gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-2.c	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-2.c	(revision 190296)
@@ -50,6 +50,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_element_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/vect-peel-3.c
===================================================================
--- gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-3.c	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-3.c	(revision 190296)
@@ -4,10 +4,8 @@
 #include "tree-vect.h"
 
 #define N 128
-#define RES 21888 
+#define RES 21640 
 
-/* unaligned store.  */
-
 int ib[N+10];
 int ia[N+10];
 int ic[N+10];
@@ -18,11 +16,11 @@
   int i, suma = 0, sumb = 0, sumc = 0;
 
   /* ib and ic have same misalignment, we peel to align them.  */
-  for (i = 1; i <= N; i++)
+  for (i = 0; i <= N; i++)
     {
       suma += ia[i];
-      sumb += ib[i+6];
-      sumc += ic[i+2];
+      sumb += ib[i+5];
+      sumc += ic[i+1];
     }
 
   /* check results:  */
@@ -49,7 +47,7 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/vect-peel-4.c
===================================================================
--- gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-4.c	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/vect-peel-4.c	(revision 190296)
@@ -16,13 +16,13 @@
   /* Don't peel keeping one load and the store aligned.  */
   for (i = 0; i <= N; i++)
     {
-      ia[i] = ib[i] + ib[i+6];
+      ia[i] = ib[i] + ib[i+5];
     }
 
   /* check results:  */
   for (i = 1; i <= N; i++)
     {
-      if (ia[i] != ib[i] + ib[i+6])
+      if (ia[i] != ib[i] + ib[i+5])
         abort ();
     }
 
@@ -44,7 +44,7 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/slp-25.c
===================================================================
--- gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/slp-25.c	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/vect/slp-25.c	(revision 190296)
@@ -57,5 +57,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || { ! vect_natural_alignment } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc-4_6-branch/gcc/testsuite/ChangeLog	(revision 190295)
+++ gcc-4_6-branch/gcc/testsuite/ChangeLog	(revision 190296)
@@ -1,3 +1,33 @@
+2012-08-10  Ulrich Weigand  <ulrich.weigand@linaro.org>
+
+	Backport from mainline
+	2012-07-30  Ulrich Weigand  <ulrich.weigand@linaro.org>
+
+	* lib/target-supports.exp
+	(check_effective_target_vect_natural_alignment): New function.
+	* gcc.dg/align-2.c: Only run on targets with natural alignment
+	of vector types.
+	* gcc.dg/vect/slp-25.c: Adjust tests for targets without natural
+	alignment of vector types.
+
+	2011-12-21  Michael Zolotukhin  <michael.v.zolotukhin@intel.com>
+
+	* gcc.dg/vect/vect-peel-1.c: Adjust test diag-scans to fix fail on AVX.
+	* gcc.dg/vect/vect-peel-2.c: Ditto.
+
+	2011-06-21  Ira Rosen  <ira.rosen@linaro.org>
+
+	PR testsuite/49443
+	* gcc.dg/vect/vect-peel-3.c: Expect to fail on vect_no_align
+	targets.
+	* gcc.dg/vect/vect-peel-4.c: Likewise.
+
+	2011-06-14  Ira Rosen  <ira.rosen@linaro.org>
+
+	* gcc.dg/vect/vect-peel-3.c: Adjust misalignment values
+	for double-word vectors.
+	* gcc.dg/vect/vect-peel-4.c: Likewise.
+
 2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>
 
 	Backport from trunk:
Index: gcc/stor-layout.c
===================================================================
--- gcc-4_6-branch/gcc/stor-layout.c	(revision 190295)
+++ gcc-4_6-branch/gcc/stor-layout.c	(revision 190296)
@@ -1927,9 +1927,17 @@
 	TYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),
 					    bitsize_int (nunits), 0);
 
-	/* Always naturally align vectors.  This prevents ABI changes
-	   depending on whether or not native vector modes are supported.  */
-	TYPE_ALIGN (type) = tree_low_cst (TYPE_SIZE (type), 0);
+	/* For vector types, we do not default to the mode's alignment.
+	   Instead, query a target hook, defaulting to natural alignment.
+	   This prevents ABI changes depending on whether or not native
+	   vector modes are supported.  */
+	TYPE_ALIGN (type) = targetm.vector_alignment (type);
+
+	/* However, if the underlying mode requires a bigger alignment than
+	   what the target hook provides, we cannot use the mode.  For now,
+	   simply reject that case.  */
+	gcc_assert (TYPE_ALIGN (type)
+		    >= GET_MODE_ALIGNMENT (TYPE_MODE (type)));
         break;
       }
 
Index: gcc/tree-vect-data-refs.c
===================================================================
--- gcc-4_6-branch/gcc/tree-vect-data-refs.c	(revision 190295)
+++ gcc-4_6-branch/gcc/tree-vect-data-refs.c	(revision 190296)
@@ -1019,7 +1019,7 @@
       int misal = DR_MISALIGNMENT (dr);
       tree vectype = STMT_VINFO_VECTYPE (stmt_info);
       misal += negative ? -npeel * dr_size : npeel * dr_size;
-      misal &= GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;
+      misal &= (TYPE_ALIGN (vectype) / BITS_PER_UNIT) - 1;
       SET_DR_MISALIGNMENT (dr, misal);
       return;
     }
Index: gcc/config/arm/arm.c
===================================================================
--- gcc-4_6-branch/gcc/config/arm/arm.c	(revision 190295)
+++ gcc-4_6-branch/gcc/config/arm/arm.c	(revision 190296)
@@ -243,6 +243,7 @@
 static bool fa726te_sched_adjust_cost (rtx, rtx, rtx, int *);
 static enum machine_mode arm_preferred_simd_mode (enum machine_mode);
 static bool arm_class_likely_spilled_p (reg_class_t);
+static HOST_WIDE_INT arm_vector_alignment (const_tree type);
 static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);
 static bool arm_builtin_support_vector_misalignment (enum machine_mode mode,
 						     const_tree type,
@@ -579,6 +580,9 @@
 #undef TARGET_CLASS_LIKELY_SPILLED_P
 #define TARGET_CLASS_LIKELY_SPILLED_P arm_class_likely_spilled_p
 
+#undef TARGET_VECTOR_ALIGNMENT
+#define TARGET_VECTOR_ALIGNMENT arm_vector_alignment
+
 #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE
 #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \
   arm_vector_alignment_reachable
@@ -4693,6 +4697,18 @@
   return gen_rtx_REG (mode, pcum->nregs);
 }
 
+/* The AAPCS sets the maximum alignment of a vector to 64 bits.  */
+static HOST_WIDE_INT
+arm_vector_alignment (const_tree type)
+{
+  HOST_WIDE_INT align = tree_low_cst (TYPE_SIZE (type), 0);
+
+  if (TARGET_AAPCS_BASED)
+    align = MIN (align, 64);
+
+  return align;
+}
+
 static unsigned int
 arm_function_arg_boundary (enum machine_mode mode, const_tree type)
 {
