[4.7 Regression] ICE in gimple_has_side_effects, at gimple.c:2513

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51071

--- gcc-4_6-branch/gcc/ChangeLog	2012/05/22 09:20:15	187763
+++ gcc-4_6-branch/gcc/ChangeLog	2012/05/22 09:23:01	187764
@@ -1,6 +1,15 @@
 	bitfield accesses.
 	* tree-vect-data-refs.c (vect_analyze_data_refs): Likewise.
 
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-11-10  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/51071
+	* gimple.c (gimple_has_side_effects): Remove checking code
+	that doesn't belong here.
+
 2012-04-28  Joern Rennecke  <joern.rennecke@embecosm.com>
 	    Steven Bosscher  <steven@gcc.gnu.org>
 	    Maxim Kuvyrkov  <maxim@codesourcery.com>
--- gcc-4_6-branch/gcc/gimple.c	2012/05/22 09:20:15	187763
+++ gcc-4_6-branch/gcc/gimple.c	2012/05/22 09:23:01	187764
@@ -2275,8 +2275,6 @@
 bool
 gimple_has_side_effects (const_gimple s)
 {
-  unsigned i;
-
   if (is_gimple_debug (s))
     return false;
 
@@ -2292,45 +2290,15 @@
 
   if (is_gimple_call (s))
     {
-      unsigned nargs = gimple_call_num_args (s);
+      int flags = gimple_call_flags (s);
 
-      if (!(gimple_call_flags (s) & (ECF_CONST | ECF_PURE)))
-        return true;
-      else if (gimple_call_flags (s) & ECF_LOOPING_CONST_OR_PURE)
-	/* An infinite loop is considered a side effect.  */
+      /* An infinite loop is considered a side effect.  */
+      if (!(flags & (ECF_CONST | ECF_PURE))
+	  || (flags & ECF_LOOPING_CONST_OR_PURE))
 	return true;
 
-      if (gimple_call_lhs (s)
-          && TREE_SIDE_EFFECTS (gimple_call_lhs (s)))
-	{
-	  gcc_checking_assert (gimple_has_volatile_ops (s));
-	  return true;
-	}
-
-      if (TREE_SIDE_EFFECTS (gimple_call_fn (s)))
-        return true;
-
-      for (i = 0; i < nargs; i++)
-        if (TREE_SIDE_EFFECTS (gimple_call_arg (s, i)))
-	  {
-	    gcc_checking_assert (gimple_has_volatile_ops (s));
-	    return true;
-	  }
-
       return false;
     }
-  else
-    {
-      for (i = 0; i < gimple_num_ops (s); i++)
-	{
-	  tree op = gimple_op (s, i);
-	  if (op && TREE_SIDE_EFFECTS (op))
-	    {
-	      gcc_checking_assert (gimple_has_volatile_ops (s));
-	      return true;
-	    }
-	}
-    }
 
   return false;
 }
--- gcc-4_6-branch/gcc/testsuite/ChangeLog	2012/05/22 09:20:15	187763
+++ gcc-4_6-branch/gcc/testsuite/ChangeLog	2012/05/22 09:23:01	187764
@@ -1,6 +1,15 @@
 	PR tree-optimization/53516
 	* gcc.dg/torture/pr53516.c: New testcase.
 
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-11-10  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/51071
+	* gcc.dg/torture/pr51071.c: New testcase.
+	* gcc.dg/torture/pr51071-2.c: Likewise.
+
 2012-04-03  Jason Merrill  <jason@redhat.com>
 
 	PR c++/52796
--- /dev/null
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/torture/pr51071.c	2012/05/22 09:23:01	187764
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+
+void foo (void);
+void bar (void *);
+extern int t;
+
+static void kmalloc_large (int size, int flags)
+{
+  (void) size;
+  (void) flags;
+  foo ();
+  bar (({__here:&&__here;}));
+}
+
+static void kmalloc (int size, int flags)
+{
+  if (size)
+    {
+      if ((unsigned long) size > 0x1000)
+	kmalloc_large (size, flags);
+
+      if (flags)
+	bar (({__here:&&__here;}));
+    }
+}
+
+void compress_file_range (int i, int j, int k)
+{
+  int nr_pages = ({j < k;});
+
+  if (i || t)
+    kmalloc (0x1000UL * nr_pages, 0x40UL);
+}
--- /dev/null
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/torture/pr51071-2.c	2012/05/22 09:23:01	187764
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-fno-delete-null-pointer-checks" } */
+
+extern struct module __this_module;
+static inline void
+trace_module_get  (struct module *mod, unsigned long ip) { }
+struct module;
+static inline __attribute__((no_instrument_function))
+int try_module_get(struct module *module)
+{
+  int ret = 1;
+  if (module)
+    {
+      if (module_is_live(module))
+	{
+	  __label__ __here;
+	  asm("");
+	  __here:
+	  trace_module_get(module, (unsigned long)&&__here);
+	}
+      else
+	ret = 0;
+    }
+  return ret;
+}
+struct net_device;
+struct net_device_ops {
+    int (*ndo_open)(struct net_device *dev);
+};
+int t3e3_open(struct net_device *dev)
+{
+  int ret = hdlc_open(dev);
+  if (ret)
+    return ret;
+  try_module_get((&__this_module));
+  return 0;
+}
+const struct net_device_ops t3e3_ops = { .ndo_open = t3e3_open };
