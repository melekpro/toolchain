Too strong non-aliasing analysis?

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=54945

--- gcc-4_6-branch/gcc/ChangeLog	(revision 192618)
+++ gcc-4_6-branch/gcc/ChangeLog	(revision 192619)
@@ -1,3 +1,12 @@
+2012-10-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2012-10-19  Marek Polacek  <polacek@redhat.com>
+
+	PR middle-end/54945
+	* fold-const.c (fold_sign_changed_comparison):  Punt if folding
+	pointer/non-pointer comparison.
+
 2012-09-15  Joseph Myers  <joseph@codesourcery.com>
 
 	PR c/54552
--- gcc-4_6-branch/gcc/fold-const.c	(revision 192618)
+++ gcc-4_6-branch/gcc/fold-const.c	(revision 192619)
@@ -6771,12 +6771,14 @@
 	   && TREE_TYPE (TREE_OPERAND (arg1, 0)) == inner_type))
     return NULL_TREE;
 
-  if ((TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)
-       || POINTER_TYPE_P (inner_type) != POINTER_TYPE_P (outer_type))
+  if (TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)
       && code != NE_EXPR
       && code != EQ_EXPR)
     return NULL_TREE;
 
+  if (POINTER_TYPE_P (inner_type) != POINTER_TYPE_P (outer_type))
+    return NULL_TREE;
+
   if (TREE_CODE (arg1) == INTEGER_CST)
     arg1 = force_fit_type_double (inner_type, tree_to_double_int (arg1),
 				  0, TREE_OVERFLOW (arg1));
