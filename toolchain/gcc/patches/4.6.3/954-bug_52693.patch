Wrong code with SRA and arrays

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52693

--- gcc-4_6-branch/gcc/ChangeLog	2012/03/28 15:04:45	185920
+++ gcc-4_6-branch/gcc/ChangeLog	2012/03/28 18:03:28	185921
@@ -1,6 +1,16 @@
 	benefit speed path.
 	(execute_pre): Use flag_tree_partial_pre.
 
+2012-03-28  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2012-03-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/52693
+	* tree-sra.c (sra_modify_assign): Do not call
+	load_assign_lhs_subreplacements when working with an unscalarizable
+	region.
+
 2012-03-24  Jan Hubicka  <jh@suse.cz>
 
 	Backport from mainline
--- gcc-4_6-branch/gcc/testsuite/ChangeLog	2012/03/28 15:04:45	185920
+++ gcc-4_6-branch/gcc/testsuite/ChangeLog	2012/03/28 18:03:28	185921
@@ -1,6 +1,14 @@
 	PR c++/52796
 	* g++.dg/cpp0x/variadic-value1.C: New.
 
+2012-03-28  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2012-03-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/52693
+	* gcc.dg/torture/pr52693.c: New test.
+
 2012-03-24  Jan Hubicka  <jh@suse.cz>
 
 	PR middle-end/51737
--- /dev/null
+++ gcc-4_6-branch/gcc/testsuite/gcc.dg/torture/pr52693.c	2012/03/28 18:03:28	185921
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+struct pair
+{
+  int x;
+  int y;
+};
+
+struct array
+{
+  struct pair elems[ 2 ];
+  unsigned index;
+};
+
+extern void abort ();
+
+void __attribute__ ((noinline,noclone))
+test_results (int x1, int y1, int x2, int y2)
+{
+  if (x1 != x2 || y1 != y2)
+    abort ();
+}
+
+int
+main (void)
+{
+  struct array arr = {{{1,2}, {3,4}}, 1};
+  struct pair last = arr.elems[arr.index];
+
+  test_results ( last.x, last.y, arr.elems[1].x, arr.elems[1].y);
+
+  return 0;
+}
--- gcc-4_6-branch/gcc/tree-sra.c	2012/03/28 15:04:45	185920
+++ gcc-4_6-branch/gcc/tree-sra.c	2012/03/28 18:03:28	185921
@@ -2937,7 +2937,13 @@
     }
   else
     {
-      if (access_has_children_p (lacc) && access_has_children_p (racc))
+      if (access_has_children_p (lacc)
+	  && access_has_children_p (racc)
+	  /* When an access represents an unscalarizable region, it usually
+	     represents accesses with variable offset and thus must not be used
+	     to generate new memory accesses.  */
+	  && !lacc->grp_unscalarizable_region
+	  && !racc->grp_unscalarizable_region)
 	{
 	  gimple_stmt_iterator orig_gsi = *gsi;
 	  enum unscalarized_data_handling refreshed;
