[4.5/4.6/4.7 Regression] Debug stepping behavior regarding g++ Class destructor has changed for the worse starting at gcc 4.5.0

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=49951

--- gcc-4_5-branch/gcc/testsuite/ChangeLog	(revision 182807)
+++ gcc-4_5-branch/gcc/testsuite/ChangeLog	(revision 182808)
@@ -14,6 +14,11 @@
 	PR tree-optimization/48172
 	* gcc.dg/vect/pr48172.c: New testcase.
 
+2011-12-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR debug/49951
+	* g++.dg/gcov/gcov-2.C: Adjust.
+
 2011-12-13  Jason Merrill  <jason@redhat.com>
 
 	PR c++/51406
--- gcc-4_5-branch/gcc/testsuite/g++.dg/gcov/gcov-2.C	(revision 182807)
+++ gcc-4_5-branch/gcc/testsuite/g++.dg/gcov/gcov-2.C	(revision 182808)
@@ -20,7 +20,7 @@ class C {
 
 void foo()
 {
-  C c;					/* count(2) */
+  C c;					/* count(1) */
   c.seti (1);				/* count(1) */
 }
 
--- gcc-4_5-branch/gcc/cp/decl.c	(revision 182807)
+++ gcc-4_5-branch/gcc/cp/decl.c	(revision 182808)
@@ -12877,8 +12877,17 @@ cxx_maybe_build_cleanup (tree decl)
 	cleanup = call;
     }
 
+  /* build_delete sets the location of the destructor call to the
+     current location, even though the destructor is going to be
+     called later, at the end of the current scope.  This can lead to
+     a "jumpy" behaviour for users of debuggers when they step around
+     the end of the block.  So let's unset the location of the
+     destructor call instead.  */
+  if (cleanup != NULL && EXPR_P (cleanup))
+    SET_EXPR_LOCATION (cleanup, UNKNOWN_LOCATION);
   return cleanup;
 }
+
 
 /* When a stmt has been parsed, this function is called.  */
 
--- gcc-4_5-branch/gcc/cp/ChangeLog	(revision 182807)
+++ gcc-4_5-branch/gcc/cp/ChangeLog	(revision 182808)
@@ -1,3 +1,9 @@
+2011-12-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR debug/49951
+	* decl.c (cxx_maybe_build_cleanup): Don't set location of the call
+	to the destructor.
+
 2011-12-13  Jason Merrill  <jason@redhat.com>
 
 	PR c++/51406
