[4.4/4.5 Regression] Inliner bug with one-bit (1-bit) bitfield

 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=48973

--- gcc-4_4-branch/gcc/ChangeLog	2011/07/19 19:27:30	176481
+++ gcc-4_4-branch/gcc/ChangeLog	2011/07/19 19:28:41	176482
@@ -1,3 +1,17 @@
+2011-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-05-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/48973
+	* expr.c (expand_expr_real_1) <case LT_EXPR>: If do_store_flag
+	failed and the comparison has a single bit signed type, use
+	constm1_rtx instead of const1_rtx for true value.
+	(do_store_flag): If TREE_TYPE (exp) is single bit signed type, disable
+	single bit test optimization, pass -1 instead of 1 as last
+	parameter to emit_store_flag and use constm1_rtx instead of
+	const1_rtx as true value.
+
 2011-06-17  Hans-Peter Nilsson  <hp@axis.com>
 
 	Backport from mainline
--- gcc-4_4-branch/gcc/expr.c	2011/07/19 19:27:30	176481
+++ gcc-4_4-branch/gcc/expr.c	2011/07/19 19:28:41	176482
@@ -9113,10 +9113,12 @@
 	  /* If temp is constant, we can just compute the result.  */
 	  if (GET_CODE (temp) == CONST_INT)
 	    {
-	      if (INTVAL (temp) != 0)
-	        emit_move_insn (target, const1_rtx);
-	      else
+	      if (INTVAL (temp) == 0)
 	        emit_move_insn (target, const0_rtx);
+	      else if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))
+		emit_move_insn (target, constm1_rtx);
+	      else
+	        emit_move_insn (target, const1_rtx);
 
 	      return target;
 	    }
@@ -9133,7 +9135,9 @@
 	  op1 = gen_label_rtx ();
 	  emit_cmp_and_jump_insns (temp, const0_rtx, EQ, NULL_RTX,
 				   GET_MODE (temp), unsignedp, op1);
-	  emit_move_insn (temp, const1_rtx);
+	  emit_move_insn (temp,
+			  TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type)
+			  ? constm1_rtx : const1_rtx);
 	  emit_label (op1);
 	  return temp;
 	}
@@ -9757,7 +9761,7 @@
   rtx op0, op1;
   enum insn_code icode;
   rtx subtarget = target;
-  rtx result, label;
+  rtx result, label, trueval = const1_rtx;
 
   /* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the
      result at the end.  We can't simply invert the test since it would
@@ -9887,7 +9891,9 @@
 
   if ((code == NE || code == EQ)
       && TREE_CODE (arg0) == BIT_AND_EXPR && integer_zerop (arg1)
-      && integer_pow2p (TREE_OPERAND (arg0, 1)))
+      && integer_pow2p (TREE_OPERAND (arg0, 1))
+      && (TYPE_PRECISION (TREE_TYPE (exp)) != 1
+	  || TYPE_UNSIGNED (TREE_TYPE (exp))))
     {
       tree type = lang_hooks.types.type_for_mode (mode, unsignedp);
       return expand_expr (fold_single_bit_test (code == NE ? NE_EXPR : EQ_EXPR,
@@ -9939,13 +9945,18 @@
   if (target == 0)
     target = gen_reg_rtx (mode);
 
+  if (TYPE_PRECISION (TREE_TYPE (exp)) == 1
+      && !TYPE_UNSIGNED (TREE_TYPE (exp)))
+    trueval = constm1_rtx;
+
   result = emit_store_flag (target, code, op0, op1,
-			    operand_mode, unsignedp, 1);
+			    operand_mode, unsignedp,
+			    trueval == const1_rtx ? 1 : -1);
 
   if (result)
     {
       if (invert)
-	result = expand_binop (mode, xor_optab, result, const1_rtx,
+	result = expand_binop (mode, xor_optab, result, trueval,
 			       result, 0, OPTAB_LIB_WIDEN);
       return result;
     }
@@ -9955,12 +9966,12 @@
       || reg_mentioned_p (target, op0) || reg_mentioned_p (target, op1))
     target = gen_reg_rtx (GET_MODE (target));
 
-  emit_move_insn (target, invert ? const0_rtx : const1_rtx);
+  emit_move_insn (target, invert ? const0_rtx : trueval);
   label = gen_label_rtx ();
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, operand_mode, NULL_RTX,
 			   NULL_RTX, label, -1);
 
-  emit_move_insn (target, invert ? const1_rtx : const0_rtx);
+  emit_move_insn (target, invert ? trueval : const0_rtx);
   emit_label (label);
 
   return target;
--- gcc-4_4-branch/gcc/testsuite/ChangeLog	2011/07/19 19:27:30	176481
+++ gcc-4_4-branch/gcc/testsuite/ChangeLog	2011/07/19 19:28:41	176482
@@ -1,3 +1,12 @@
+2011-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-05-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/48973
+	* gcc.c-torture/execute/pr48973-1.c: New test.
+	* gcc.c-torture/execute/pr48973-2.c: New test.
+
 2011-06-17  Hans-Peter Nilsson  <hp@axis.com>
 
 	Backport from mainline
--- /dev/null
+++ gcc-4_4-branch/gcc/testsuite/gcc.c-torture/execute/pr48973-1.c	2011/07/19 19:28:41	176482
@@ -0,0 +1,20 @@
+/* PR middle-end/48973 */
+
+extern void abort (void);
+struct S { int f : 1; } s;
+int v = -1;
+
+void
+foo (unsigned int x)
+{
+  if (x != -1U)
+    abort ();
+}
+
+int
+main ()
+{
+  s.f = (v & 1) > 0;
+  foo (s.f);
+  return 0;
+}
--- /dev/null
+++ gcc-4_4-branch/gcc/testsuite/gcc.c-torture/execute/pr48973-2.c	2011/07/19 19:28:41	176482
@@ -0,0 +1,14 @@
+/* PR middle-end/48973 */
+
+extern void abort (void);
+struct S { int f : 1; } s;
+int v = -1;
+
+int
+main ()
+{
+  s.f = v < 0;
+  if ((unsigned int) s.f != -1U)
+    abort ();
+  return 0;
+}
