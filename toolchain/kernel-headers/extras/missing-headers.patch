diff -urBN hndtools-mipsel-uclibc-4.1.2/include/bits/string2.h hndtools-mipsel-uclibc-4.1.2.full/include/bits/string2.h
--- hndtools-mipsel-uclibc-4.1.2/include/bits/string2.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/bits/string2.h	2009-01-13 12:16:52.000000000 +0300
@@ -0,0 +1,1269 @@
+/* Machine-independant string function optimizations.
+   Copyright (C) 1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STRING_H
+# error "Never use <bits/string2.h> directly; include <string.h> instead."
+#endif
+
+#if !defined __NO_STRING_INLINES && !defined __BOUNDED_POINTERS__
+
+/* Unlike the definitions in the header <bits/string.h> the
+   definitions contained here are not optimized down to assembler
+   level.  Those optimizations are not always a good idea since this
+   means the code size increases a lot.  Instead the definitions here
+   optimize some functions in a way which do not dramatically
+   increase the code size and which do not use assembler.  The main
+   trick is to use GNU CC's `__builtin_constant_p' function.
+
+   Every function XXX which has a defined version in
+   <bits/string.h> must be accompanied by a symbol _HAVE_STRING_ARCH_XXX
+   to make sure we don't get redefinitions.
+
+   We must use here macros instead of inline functions since the
+   trick won't work with the latter.  */
+
+#ifndef __STRING_INLINE
+# ifdef __cplusplus
+#  define __STRING_INLINE inline
+# else
+#  define __STRING_INLINE extern __inline
+# endif
+#endif
+
+#if _STRING_ARCH_unaligned
+/* If we can do unaligned memory accesses we must know the endianess.  */
+# include <endian.h>
+# include <bits/types.h>
+
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __STRING2_SMALL_GET16(src, idx) \
+     (((__const unsigned char *) (__const char *) (src))[idx + 1] << 8	      \
+      | ((__const unsigned char *) (__const char *) (src))[idx])
+#  define __STRING2_SMALL_GET32(src, idx) \
+     (((((__const unsigned char *) (__const char *) (src))[idx + 3] << 8      \
+	| ((__const unsigned char *) (__const char *) (src))[idx + 2]) << 8   \
+       | ((__const unsigned char *) (__const char *) (src))[idx + 1]) << 8    \
+      | ((__const unsigned char *) (__const char *) (src))[idx])
+# else
+#  define __STRING2_SMALL_GET16(src, idx) \
+     (((__const unsigned char *) (__const char *) (src))[idx] << 8	      \
+      | ((__const unsigned char *) (__const char *) (src))[idx + 1])
+#  define __STRING2_SMALL_GET32(src, idx) \
+     (((((__const unsigned char *) (__const char *) (src))[idx] << 8	      \
+	| ((__const unsigned char *) (__const char *) (src))[idx + 1]) << 8   \
+       | ((__const unsigned char *) (__const char *) (src))[idx + 2]) << 8    \
+      | ((__const unsigned char *) (__const char *) (src))[idx + 3])
+# endif
+#else
+/* These are a few types we need for the optimizations if we cannot
+   use unaligned memory accesses.  */
+# define __STRING2_COPY_TYPE(N) \
+  typedef struct { unsigned char __arr[N]; }				      \
+    __STRING2_COPY_ARR##N __attribute__ ((packed))
+__STRING2_COPY_TYPE (2);
+__STRING2_COPY_TYPE (3);
+__STRING2_COPY_TYPE (4);
+__STRING2_COPY_TYPE (5);
+__STRING2_COPY_TYPE (6);
+__STRING2_COPY_TYPE (7);
+__STRING2_COPY_TYPE (8);
+# undef __STRING2_COPY_TYPE
+#endif
+
+/* Dereferencing a pointer arg to run sizeof on it fails for the void
+   pointer case, so we use this instead.
+   Note that __x is evaluated twice. */
+#define __string2_1bptr_p(__x) \
+  ((size_t)(const void *)((__x) + 1) - (size_t)(const void *)(__x) == 1)
+
+/* Set N bytes of S to C.  */
+#ifndef _HAVE_STRING_ARCH_memset
+# if _STRING_ARCH_unaligned
+#  define memset(s, c, n) \
+  (__extension__ (__builtin_constant_p (n) && (n) <= 16			      \
+		  ? ((n) == 1						      \
+		     ? __memset_1 (s, c)				      \
+		     : __memset_gc (s, c, n))				      \
+		  : (__builtin_constant_p (c) && (c) == '\0'		      \
+		     ? ({ void *__s = (s); __bzero (__s, n); __s; })	      \
+		     : memset (s, c, n))))
+
+#  define __memset_1(s, c) ({ void *__s = (s);				      \
+			    *((__uint8_t *) __s) = (__uint8_t) c; __s; })
+
+#  define __memset_gc(s, c, n) \
+  ({ void *__s = (s);							      \
+     union {								      \
+       unsigned int __ui;						      \
+       unsigned short int __usi;					      \
+       unsigned char __uc;						      \
+     } *__u = __s;							      \
+     __uint8_t __c = (__uint8_t) (c);					      \
+									      \
+     /* This `switch' statement will be removed at compile-time.  */	      \
+     switch ((unsigned int) (n))					      \
+       {								      \
+       case 15:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 11:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 7:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 3:								      \
+	 __u->__usi = (unsigned short int) __c * 0x0101;		      \
+	 __u = __extension__ (void *)((char *) __u + 2);		      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 14:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 10:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 6:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 2:								      \
+	 __u->__usi = (unsigned short int) __c * 0x0101;		      \
+	 break;								      \
+									      \
+       case 13:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 9:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 5:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 1:								      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 16:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 12:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 8:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ (void *)((char *) __u + 4);		      \
+       case 4:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+       case 0:								      \
+	 break;								      \
+       }								      \
+									      \
+     __s; })
+# else
+#  define memset(s, c, n) \
+  (__extension__ (__builtin_constant_p (c) && (c) == '\0'		      \
+		  ? ({ void *__s = (s); __bzero (__s, n); __s; })	      \
+		  : memset (s, c, n)))
+# endif
+
+/* GCC optimizes memset(s, 0, n) but not bzero(s, n).
+   The optimization is broken before EGCS 1.1.  */
+# if __GNUC_PREREQ (2, 91)
+#  define __bzero(s, n) __builtin_memset (s, '\0', n)
+# endif
+
+#endif
+
+
+/* Copy N bytes from SRC to DEST, returning pointer to byte following the
+   last copied.  */
+#ifdef __USE_GNU
+# if !defined _HAVE_STRING_ARCH_mempcpy || defined _FORCE_INLINES
+#  ifndef _HAVE_STRING_ARCH_mempcpy
+#   if __GNUC_PREREQ (3, 4)
+#    define __mempcpy(dest, src, n) __builtin_mempcpy (dest, src, n)
+#   if __GNUC_PREREQ (3, 0)
+#    define __mempcpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  && __string2_1bptr_p (src) && n <= 8			      \
+		  ? __builtin_memcpy (dest, src, n) + (n)		      \
+		  : __mempcpy (dest, src, n)))
+#   else
+#    define __mempcpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  && __string2_1bptr_p (src) && n <= 8			      \
+		  ? __mempcpy_small (dest, __mempcpy_args (src), n)	      \
+		  : __mempcpy (dest, src, n)))
+#   endif
+/* In glibc we use this function frequently but for namespace reasons
+   we have to use the name `__mempcpy'.  */
+#   define mempcpy(dest, src, n) __mempcpy (dest, src, n)
+#  endif
+
+#  if !__GNUC_PREREQ (3, 0) || defined _FORCE_INLINES
+#   if _STRING_ARCH_unaligned
+#    ifndef _FORCE_INLINES
+#     define __mempcpy_args(src) \
+     ((__const char *) (src))[0], ((__const char *) (src))[2],		      \
+     ((__const char *) (src))[4], ((__const char *) (src))[6],		      \
+     __extension__ __STRING2_SMALL_GET16 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET16 (src, 4),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 4)
+#    endif
+__STRING_INLINE void *__mempcpy_small (void *, char, char, char, char,
+				       __uint16_t, __uint16_t, __uint32_t,
+				       __uint32_t, size_t);
+__STRING_INLINE void *
+__mempcpy_small (void *__dest1,
+		 char __src0_1, char __src2_1, char __src4_1, char __src6_1,
+		 __uint16_t __src0_2, __uint16_t __src4_2,
+		 __uint32_t __src0_4, __uint32_t __src4_4,
+		 size_t __srclen)
+{
+  union {
+    __uint32_t __ui;
+    __uint16_t __usi;
+    unsigned char __uc;
+    unsigned char __c;
+  } *__u = __dest1;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = __src0_1;
+      __u = __extension__ (void *)((char *) __u + 1);
+      break;
+    case 2:
+      __u->__usi = __src0_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      break;
+    case 3:
+      __u->__usi = __src0_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      __u->__c = __src2_1;
+      __u = __extension__ (void *)((char *) __u + 1);
+      break;
+    case 4:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      break;
+    case 5:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__c = __src4_1;
+      __u = __extension__ (void *)((char *) __u + 1);
+      break;
+    case 6:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      break;
+    case 7:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      __u->__c = __src6_1;
+      __u = __extension__ (void *)((char *) __u + 1);
+      break;
+    case 8:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__ui = __src4_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      break;
+    }
+  return (void *) __u;
+}
+#   else
+#    ifndef _FORCE_INLINES
+#     define __mempcpy_args(src) \
+     ((__const char *) (src))[0],					      \
+     __extension__ ((__STRING2_COPY_ARR2)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1] } }),      \
+     __extension__ ((__STRING2_COPY_ARR3)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2] } }),				      \
+     __extension__ ((__STRING2_COPY_ARR4)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3] } }),      \
+     __extension__ ((__STRING2_COPY_ARR5)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4] } }),				      \
+     __extension__ ((__STRING2_COPY_ARR6)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5] } }),      \
+     __extension__ ((__STRING2_COPY_ARR7)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5],	      \
+	  ((__const char *) (src))[6] } }),				      \
+     __extension__ ((__STRING2_COPY_ARR8)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5],	      \
+	  ((__const char *) (src))[6], ((__const char *) (src))[7] } })
+#    endif
+__STRING_INLINE void *__mempcpy_small (void *, char, __STRING2_COPY_ARR2,
+				       __STRING2_COPY_ARR3,
+				       __STRING2_COPY_ARR4,
+				       __STRING2_COPY_ARR5,
+				       __STRING2_COPY_ARR6,
+				       __STRING2_COPY_ARR7,
+				       __STRING2_COPY_ARR8, size_t);
+__STRING_INLINE void *
+__mempcpy_small (void *__dest, char __src1,
+		 __STRING2_COPY_ARR2 __src2, __STRING2_COPY_ARR3 __src3,
+		 __STRING2_COPY_ARR4 __src4, __STRING2_COPY_ARR5 __src5,
+		 __STRING2_COPY_ARR6 __src6, __STRING2_COPY_ARR7 __src7,
+		 __STRING2_COPY_ARR8 __src8, size_t __srclen)
+{
+  union {
+    char __c;
+    __STRING2_COPY_ARR2 __sca2;
+    __STRING2_COPY_ARR3 __sca3;
+    __STRING2_COPY_ARR4 __sca4;
+    __STRING2_COPY_ARR5 __sca5;
+    __STRING2_COPY_ARR6 __sca6;
+    __STRING2_COPY_ARR7 __sca7;
+    __STRING2_COPY_ARR8 __sca8;
+  } *__u = __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = __src1;
+      break;
+    case 2:
+      __extension__ __u->__sca2 = __src2;
+      break;
+    case 3:
+      __extension__ __u->__sca3 = __src3;
+      break;
+    case 4:
+      __extension__ __u->__sca4 = __src4;
+      break;
+    case 5:
+      __extension__ __u->__sca5 = __src5;
+      break;
+    case 6:
+      __extension__ __u->__sca6 = __src6;
+      break;
+    case 7:
+      __extension__ __u->__sca7 = __src7;
+      break;
+    case 8:
+      __extension__ __u->__sca8 = __src8;
+      break;
+    }
+  return __extension__ (void *)((char *) __u + __srclen);
+}
+#   endif
+#  endif
+# endif
+#endif
+
+
+/* Return pointer to C in S.  */
+#ifndef _HAVE_STRING_ARCH_strchr
+extern void *__rawmemchr (const void *__s, int __c);
+# define strchr(s, c) \
+  (__extension__ (__builtin_constant_p (c) && (c) == '\0'		      \
+		  ? (char *) __rawmemchr (s, c)				      \
+		  : strchr (s, c)))
+#endif
+
+
+/* Copy SRC to DEST.  */
+#if (!defined _HAVE_STRING_ARCH_strcpy && !__GNUC_PREREQ (3, 0)) \
+    || defined _FORCE_INLINES
+# if !defined _HAVE_STRING_ARCH_strcpy && !__GNUC_PREREQ (3, 0)
+#  define strcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (__string2_1bptr_p (src) && strlen (src) + 1 <= 8	      \
+		     ? __strcpy_small (dest, __strcpy_args (src),	      \
+				       strlen (src) + 1)		      \
+		     : (char *) memcpy (dest, src, strlen (src) + 1))	      \
+		  : strcpy (dest, src)))
+# endif
+
+# if _STRING_ARCH_unaligned
+#  ifndef _FORCE_INLINES
+#   define __strcpy_args(src) \
+     __extension__ __STRING2_SMALL_GET16 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET16 (src, 4),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 4)
+#  endif
+__STRING_INLINE char *__strcpy_small (char *, __uint16_t, __uint16_t,
+				      __uint32_t, __uint32_t, size_t);
+__STRING_INLINE char *
+__strcpy_small (char *__dest,
+		__uint16_t __src0_2, __uint16_t __src4_2,
+		__uint32_t __src0_4, __uint32_t __src4_4,
+		size_t __srclen)
+{
+  union {
+    __uint32_t __ui;
+    __uint16_t __usi;
+    unsigned char __uc;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__uc = '\0';
+      break;
+    case 2:
+      __u->__usi = __src0_2;
+      break;
+    case 3:
+      __u->__usi = __src0_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 4:
+      __u->__ui = __src0_4;
+      break;
+    case 5:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__uc = '\0';
+      break;
+    case 6:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__usi = __src4_2;
+      break;
+    case 7:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 8:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__ui = __src4_4;
+      break;
+    }
+  return __dest;
+}
+# else
+#  ifndef _FORCE_INLINES
+#   define __strcpy_args(src) \
+     __extension__ ((__STRING2_COPY_ARR2)				      \
+      { { ((__const char *) (src))[0], '\0' } }),			      \
+     __extension__ ((__STRING2_COPY_ARR3)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR4)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], '\0' } }),			      \
+     __extension__ ((__STRING2_COPY_ARR5)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR6)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], '\0' } }),			      \
+     __extension__ ((__STRING2_COPY_ARR7)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5],	      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR8)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5],	      \
+	  ((__const char *) (src))[6], '\0' } })
+#  endif
+__STRING_INLINE char *__strcpy_small (char *, __STRING2_COPY_ARR2,
+				      __STRING2_COPY_ARR3,
+				      __STRING2_COPY_ARR4,
+				      __STRING2_COPY_ARR5,
+				      __STRING2_COPY_ARR6,
+				      __STRING2_COPY_ARR7,
+				      __STRING2_COPY_ARR8, size_t);
+__STRING_INLINE char *
+__strcpy_small (char *__dest,
+		__STRING2_COPY_ARR2 __src2, __STRING2_COPY_ARR3 __src3,
+		__STRING2_COPY_ARR4 __src4, __STRING2_COPY_ARR5 __src5,
+		__STRING2_COPY_ARR6 __src6, __STRING2_COPY_ARR7 __src7,
+		__STRING2_COPY_ARR8 __src8, size_t __srclen)
+{
+  union {
+    char __c;
+    __STRING2_COPY_ARR2 __sca2;
+    __STRING2_COPY_ARR3 __sca3;
+    __STRING2_COPY_ARR4 __sca4;
+    __STRING2_COPY_ARR5 __sca5;
+    __STRING2_COPY_ARR6 __sca6;
+    __STRING2_COPY_ARR7 __sca7;
+    __STRING2_COPY_ARR8 __sca8;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = '\0';
+      break;
+    case 2:
+      __extension__ __u->__sca2 = __src2;
+      break;
+    case 3:
+      __extension__ __u->__sca3 = __src3;
+      break;
+    case 4:
+      __extension__ __u->__sca4 = __src4;
+      break;
+    case 5:
+      __extension__ __u->__sca5 = __src5;
+      break;
+    case 6:
+      __extension__ __u->__sca6 = __src6;
+      break;
+    case 7:
+      __extension__ __u->__sca7 = __src7;
+      break;
+    case 8:
+      __extension__ __u->__sca8 = __src8;
+      break;
+  }
+  return __dest;
+}
+# endif
+#endif
+
+
+/* Copy SRC to DEST, returning pointer to final NUL byte.  */
+#ifdef __USE_GNU
+# if !defined _HAVE_STRING_ARCH_stpcpy || defined _FORCE_INLINES
+#  ifndef _HAVE_STRING_ARCH_stpcpy
+#   if __GNUC_PREREQ (3, 4)
+#    define __stpcpy(dest, src) __builtin_stpcpy (dest, src)
+#   if __GNUC_PREREQ (3, 0)
+#    define __stpcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (__string2_1bptr_p (src) && strlen (src) + 1 <= 8	      \
+		     ? __builtin_strcpy (dest, src) + strlen (src)	      \
+		     : ((char *) (__mempcpy) (dest, src, strlen (src) + 1)    \
+			- 1))						      \
+		  : __stpcpy (dest, src)))
+#   else
+#    define __stpcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (__string2_1bptr_p (src) && strlen (src) + 1 <= 8	      \
+		     ? __stpcpy_small (dest, __stpcpy_args (src),	      \
+				       strlen (src) + 1)		      \
+		     : ((char *) (__mempcpy) (dest, src, strlen (src) + 1)    \
+			- 1))						      \
+		  : __stpcpy (dest, src)))
+#   endif
+/* In glibc we use this function frequently but for namespace reasons
+   we have to use the name `__stpcpy'.  */
+#   define stpcpy(dest, src) __stpcpy (dest, src)
+#  endif
+
+#  if !__GNUC_PREREQ (3, 0) || defined _FORCE_INLINES
+#   if _STRING_ARCH_unaligned
+#    ifndef _FORCE_INLINES
+#     define __stpcpy_args(src) \
+     __extension__ __STRING2_SMALL_GET16 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET16 (src, 4),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 4)
+#    endif
+__STRING_INLINE char *__stpcpy_small (char *, __uint16_t, __uint16_t,
+				      __uint32_t, __uint32_t, size_t);
+__STRING_INLINE char *
+__stpcpy_small (char *__dest,
+		__uint16_t __src0_2, __uint16_t __src4_2,
+		__uint32_t __src0_4, __uint32_t __src4_4,
+		size_t __srclen)
+{
+  union {
+    unsigned int __ui;
+    unsigned short int __usi;
+    unsigned char __uc;
+    char __c;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__uc = '\0';
+      break;
+    case 2:
+      __u->__usi = __src0_2;
+      __u = __extension__ (void *)((char *) __u + 1);
+      break;
+    case 3:
+      __u->__usi = __src0_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 4:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 3);
+      break;
+    case 5:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__uc = '\0';
+      break;
+    case 6:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ (void *)((char *) __u + 1);
+      break;
+    case 7:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ (void *)((char *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 8:
+      __u->__ui = __src0_4;
+      __u = __extension__ (void *)((char *) __u + 4);
+      __u->__ui = __src4_4;
+      __u = __extension__ (void *)((char *) __u + 3);
+      break;
+    }
+  return &__u->__c;
+}
+#   else
+#    ifndef _FORCE_INLINES
+#     define __stpcpy_args(src) \
+     __extension__ ((__STRING2_COPY_ARR2)				      \
+      { { ((__const char *) (src))[0], '\0' } }),			      \
+     __extension__ ((__STRING2_COPY_ARR3)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR4)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], '\0' } }),			      \
+     __extension__ ((__STRING2_COPY_ARR5)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR6)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], '\0' } }),			      \
+     __extension__ ((__STRING2_COPY_ARR7)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5],	      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR8)				      \
+      { { ((__const char *) (src))[0], ((__const char *) (src))[1],	      \
+	  ((__const char *) (src))[2], ((__const char *) (src))[3],	      \
+	  ((__const char *) (src))[4], ((__const char *) (src))[5],	      \
+	  ((__const char *) (src))[6], '\0' } })
+#    endif
+__STRING_INLINE char *__stpcpy_small (char *, __STRING2_COPY_ARR2,
+				      __STRING2_COPY_ARR3,
+				      __STRING2_COPY_ARR4,
+				      __STRING2_COPY_ARR5,
+				      __STRING2_COPY_ARR6,
+				      __STRING2_COPY_ARR7,
+				      __STRING2_COPY_ARR8, size_t);
+__STRING_INLINE char *
+__stpcpy_small (char *__dest,
+		__STRING2_COPY_ARR2 __src2, __STRING2_COPY_ARR3 __src3,
+		__STRING2_COPY_ARR4 __src4, __STRING2_COPY_ARR5 __src5,
+		__STRING2_COPY_ARR6 __src6, __STRING2_COPY_ARR7 __src7,
+		__STRING2_COPY_ARR8 __src8, size_t __srclen)
+{
+  union {
+    char __c;
+    __STRING2_COPY_ARR2 __sca2;
+    __STRING2_COPY_ARR3 __sca3;
+    __STRING2_COPY_ARR4 __sca4;
+    __STRING2_COPY_ARR5 __sca5;
+    __STRING2_COPY_ARR6 __sca6;
+    __STRING2_COPY_ARR7 __sca7;
+    __STRING2_COPY_ARR8 __sca8;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = '\0';
+      break;
+    case 2:
+      __extension__ __u->__sca2 = __src2;
+      break;
+    case 3:
+      __extension__ __u->__sca3 = __src3;
+      break;
+    case 4:
+      __extension__ __u->__sca4 = __src4;
+      break;
+    case 5:
+      __extension__ __u->__sca5 = __src5;
+      break;
+    case 6:
+      __extension__ __u->__sca6 = __src6;
+      break;
+    case 7:
+      __extension__ __u->__sca7 = __src7;
+      break;
+    case 8:
+      __extension__ __u->__sca8 = __src8;
+      break;
+  }
+  return __dest + __srclen - 1;
+}
+#   endif
+#  endif
+# endif
+#endif
+
+
+/* Copy no more than N characters of SRC to DEST.  */
+#ifndef _HAVE_STRING_ARCH_strncpy
+# if defined _USE_STRING_ARCH_memset && defined _USE_STRING_ARCH_mempcpy
+#  define strncpy(dest, src, n) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    __builtin_constant_p (src) && __builtin_constant_p (n)    \
+		    ? (strlen (src) + 1 >= ((size_t) (n))		      \
+		       ? (char *) memcpy (__dest, src, n)		      \
+		       : (memset (__mempcpy (__dest, src, strlen (src)),      \
+				  '\0', n - strlen (src)),		      \
+			  __dest))					      \
+		    : strncpy (__dest, src, n); }))
+# else
+#  define strncpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  ? (strlen (src) + 1 >= ((size_t) (n))			      \
+		     ? (char *) memcpy (dest, src, n)			      \
+		     : strncpy (dest, src, n))				      \
+		  : strncpy (dest, src, n)))
+# endif
+#endif
+
+
+/* Append no more than N characters from SRC onto DEST.  */
+#ifndef _HAVE_STRING_ARCH_strncat
+# ifdef _USE_STRING_ARCH_strchr
+#  define strncat(dest, src, n) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    __builtin_constant_p (src) && __builtin_constant_p (n)    \
+		    ? (strlen (src) < ((size_t) (n))			      \
+		       ? strcat (__dest, src)				      \
+		       : (*((char *) __mempcpy (strchr (__dest, '\0'),	      \
+						src, n)) = '\0', __dest))     \
+		    : strncat (dest, src, n); }))
+# else
+#  define strncat(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  ? (strlen (src) < ((size_t) (n))			      \
+		     ? strcat (dest, src)				      \
+		     : strncat (dest, src, n))				      \
+		  : strncat (dest, src, n)))
+# endif
+#endif
+
+
+/* Compare characters of S1 and S2.  */
+#ifndef _HAVE_STRING_ARCH_strcmp
+# define strcmp(s1, s2) \
+  __extension__								      \
+  ({ size_t __s1_len, __s2_len;						      \
+     (__builtin_constant_p (s1) && __builtin_constant_p (s2)		      \
+      && (__s1_len = strlen (s1), __s2_len = strlen (s2),		      \
+	  (!__string2_1bptr_p (s1) || __s1_len >= 4)			      \
+	  && (!__string2_1bptr_p (s2) || __s2_len >= 4))		      \
+      ? memcmp ((__const char *) (s1), (__const char *) (s2),		      \
+		(__s1_len < __s2_len ? __s1_len : __s2_len) + 1)	      \
+      : (__builtin_constant_p (s1) && __string2_1bptr_p (s1)		      \
+	 && (__s1_len = strlen (s1), __s1_len < 4)			      \
+	 ? (__builtin_constant_p (s2) && __string2_1bptr_p (s2)		      \
+	    ? __strcmp_cc (s1, s2, __s1_len)				      \
+	    : __strcmp_cg (s1, s2, __s1_len))				      \
+	 : (__builtin_constant_p (s2) && __string2_1bptr_p (s2)		      \
+	    && (__s2_len = strlen (s2), __s2_len < 4)			      \
+	    ? (__builtin_constant_p (s1) && __string2_1bptr_p (s1)	      \
+	       ? __strcmp_cc (s1, s2, __s2_len)				      \
+	       : __strcmp_gc (s1, s2, __s2_len))			      \
+	    : strcmp (s1, s2)))); })
+
+# define __strcmp_cc(s1, s2, l) \
+  (__extension__ ({ register int __result =				      \
+		      (((__const unsigned char *) (__const char *) (s1))[0]   \
+		       - ((__const unsigned char *) (__const char *)(s2))[0]);\
+		    if (l > 0 && __result == 0)				      \
+		      {							      \
+			__result = (((__const unsigned char *)		      \
+				     (__const char *) (s1))[1]		      \
+				    - ((__const unsigned char *)	      \
+				       (__const char *) (s2))[1]);	      \
+			if (l > 1 && __result == 0)			      \
+			  {						      \
+			    __result =					      \
+			      (((__const unsigned char *)		      \
+				(__const char *) (s1))[2]		      \
+			       - ((__const unsigned char *)		      \
+				  (__const char *) (s2))[2]);		      \
+			    if (l > 2 && __result == 0)			      \
+			      __result =				      \
+				(((__const unsigned char *)		      \
+				  (__const char *) (s1))[3]		      \
+				 - ((__const unsigned char *)		      \
+				    (__const char *) (s2))[3]);		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+# define __strcmp_cg(s1, s2, l1) \
+  (__extension__ ({ __const unsigned char *__s2 =			      \
+		      (__const unsigned char *) (__const char *) (s2);	      \
+		    register int __result =				      \
+		      (((__const unsigned char *) (__const char *) (s1))[0]   \
+		       - __s2[0]);					      \
+		    if (l1 > 0 && __result == 0)			      \
+		      {							      \
+			__result = (((__const unsigned char *)		      \
+				     (__const char *) (s1))[1] - __s2[1]);    \
+			if (l1 > 1 && __result == 0)			      \
+			  {						      \
+			    __result = (((__const unsigned char *)	      \
+					 (__const char *) (s1))[2] - __s2[2]);\
+			    if (l1 > 2 && __result == 0)		      \
+			      __result = (((__const unsigned char *)	      \
+					  (__const char *)  (s1))[3]	      \
+					  - __s2[3]);			      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+# define __strcmp_gc(s1, s2, l2) \
+  (__extension__ ({ __const unsigned char *__s1 =			      \
+		      (__const unsigned char *) (__const char *) (s1);	      \
+		    register int __result =				      \
+		      __s1[0] - ((__const unsigned char *)		      \
+				 (__const char *) (s2))[0];		      \
+		    if (l2 > 0 && __result == 0)			      \
+		      {							      \
+			__result = (__s1[1]				      \
+				    - ((__const unsigned char *)	      \
+				       (__const char *) (s2))[1]);	      \
+			if (l2 > 1 && __result == 0)			      \
+			  {						      \
+			    __result =					      \
+			      (__s1[2] - ((__const unsigned char *)	      \
+					  (__const char *) (s2))[2]);	      \
+			    if (l2 > 2 && __result == 0)		      \
+			      __result =				      \
+				(__s1[3]				      \
+				 - ((__const unsigned char *)		      \
+				    (__const char *) (s2))[3]);		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+#endif
+
+
+/* Compare N characters of S1 and S2.  */
+#ifndef _HAVE_STRING_ARCH_strncmp
+# define strncmp(s1, s2, n)						      \
+  (__extension__ (__builtin_constant_p (n)				      \
+		  && ((__builtin_constant_p (s1)			      \
+		       && strlen (s1) < ((size_t) (n)))			      \
+		      || (__builtin_constant_p (s2)			      \
+			  && strlen (s2) < ((size_t) (n))))		      \
+		  ? strcmp (s1, s2) : strncmp (s1, s2, n)))
+#endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+#if !defined _HAVE_STRING_ARCH_strcspn || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strcspn
+#  define strcspn(s, reject) \
+  __extension__								      \
+  ({ char __r0, __r1, __r2;						      \
+     (__builtin_constant_p (reject) && __string2_1bptr_p (reject)	      \
+      ? ((__r0 = ((__const char *) (reject))[0], __r0 == '\0')		      \
+	 ? strlen (s)							      \
+	 : ((__r1 = ((__const char *) (reject))[1], __r1 == '\0')	      \
+	    ? __strcspn_c1 (s, __r0)					      \
+	    : ((__r2 = ((__const char *) (reject))[2], __r2 == '\0')	      \
+	       ? __strcspn_c2 (s, __r0, __r1)				      \
+	       : (((__const char *) (reject))[3] == '\0'		      \
+		  ? __strcspn_c3 (s, __r0, __r1, __r2)			      \
+		  : strcspn (s, reject)))))				      \
+		  : strcspn (s, reject)); })
+# endif
+
+__STRING_INLINE size_t __strcspn_c1 (__const char *__s, int __reject);
+__STRING_INLINE size_t
+__strcspn_c1 (__const char *__s, int __reject)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strcspn_c2 (__const char *__s, int __reject1,
+				     int __reject2);
+__STRING_INLINE size_t
+__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+	 && __s[__result] != __reject2)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strcspn_c3 (__const char *__s, int __reject1,
+				     int __reject2, int __reject3);
+__STRING_INLINE size_t
+__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
+	      int __reject3)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+	 && __s[__result] != __reject2 && __s[__result] != __reject3)
+    ++__result;
+  return __result;
+}
+#endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+#if !defined _HAVE_STRING_ARCH_strspn || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strspn
+#  define strspn(s, accept) \
+  __extension__								      \
+  ({ char __a0, __a1, __a2;						      \
+     (__builtin_constant_p (accept) && __string2_1bptr_p (accept)	      \
+      ? ((__a0 = ((__const char *) (accept))[0], __a0 == '\0')		      \
+	 ? ((void) (s), 0)						      \
+	 : ((__a1 = ((__const char *) (accept))[1], __a1 == '\0')	      \
+	    ? __strspn_c1 (s, __a0)					      \
+	    : ((__a2 = ((__const char *) (accept))[2], __a2 == '\0')	      \
+	       ? __strspn_c2 (s, __a0, __a1)				      \
+	       : (((__const char *) (accept))[3] == '\0'		      \
+		  ? __strspn_c3 (s, __a0, __a1, __a2)			      \
+		  : strspn (s, accept)))))				      \
+      : strspn (s, accept)); })
+# endif
+
+__STRING_INLINE size_t __strspn_c1 (__const char *__s, int __accept);
+__STRING_INLINE size_t
+__strspn_c1 (__const char *__s, int __accept)
+{
+  register size_t __result = 0;
+  /* Please note that __accept never can be '\0'.  */
+  while (__s[__result] == __accept)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strspn_c2 (__const char *__s, int __accept1,
+				    int __accept2);
+__STRING_INLINE size_t
+__strspn_c2 (__const char *__s, int __accept1, int __accept2)
+{
+  register size_t __result = 0;
+  /* Please note that __accept1 and __accept2 never can be '\0'.  */
+  while (__s[__result] == __accept1 || __s[__result] == __accept2)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strspn_c3 (__const char *__s, int __accept1,
+				    int __accept2, int __accept3);
+__STRING_INLINE size_t
+__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
+{
+  register size_t __result = 0;
+  /* Please note that __accept1 to __accept3 never can be '\0'.  */
+  while (__s[__result] == __accept1 || __s[__result] == __accept2
+	 || __s[__result] == __accept3)
+    ++__result;
+  return __result;
+}
+#endif
+
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#if !defined _HAVE_STRING_ARCH_strpbrk || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strpbrk
+#  define strpbrk(s, accept) \
+  __extension__								      \
+  ({ char __a0, __a1, __a2;						      \
+     (__builtin_constant_p (accept) && __string2_1bptr_p (accept)	      \
+      ? ((__a0 = ((__const char  *) (accept))[0], __a0 == '\0')		      \
+	 ? ((void) (s), NULL)						      \
+	 : ((__a1 = ((__const char *) (accept))[1], __a1 == '\0')	      \
+	    ? strchr (s, __a0)						      \
+	    : ((__a2 = ((__const char *) (accept))[2], __a2 == '\0')	      \
+	       ? __strpbrk_c2 (s, __a0, __a1)				      \
+	       : (((__const char *) (accept))[3] == '\0'		      \
+		  ? __strpbrk_c3 (s, __a0, __a1, __a2)			      \
+		  : strpbrk (s, accept)))))				      \
+      : strpbrk (s, accept)); })
+# endif
+
+__STRING_INLINE char *__strpbrk_c2 (__const char *__s, int __accept1,
+				     int __accept2);
+__STRING_INLINE char *
+__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
+{
+  /* Please note that __accept1 and __accept2 never can be '\0'.  */
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
+    ++__s;
+  return *__s == '\0' ? NULL : (char *) (size_t) __s;
+}
+
+__STRING_INLINE char *__strpbrk_c3 (__const char *__s, int __accept1,
+				     int __accept2, int __accept3);
+__STRING_INLINE char *
+__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
+	      int __accept3)
+{
+  /* Please note that __accept1 to __accept3 never can be '\0'.  */
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
+	 && *__s != __accept3)
+    ++__s;
+  return *__s == '\0' ? NULL : (char *) (size_t) __s;
+}
+#endif
+
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  Newer gcc versions
+   do this itself.  */
+#if !defined _HAVE_STRING_ARCH_strstr && !__GNUC_PREREQ (2, 97)
+# define strstr(haystack, needle) \
+  (__extension__ (__builtin_constant_p (needle) && __string2_1bptr_p (needle) \
+		  ? (((__const char *) (needle))[0] == '\0'		      \
+		     ? (char *) (size_t) (haystack)			      \
+		     : (((__const char *) (needle))[1] == '\0'		      \
+			? strchr (haystack,				      \
+				  ((__const char *) (needle))[0]) 	      \
+			: strstr (haystack, needle)))			      \
+		  : strstr (haystack, needle)))
+#endif
+
+
+#if !defined _HAVE_STRING_ARCH_strtok_r || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strtok_r
+#  define __strtok_r(s, sep, nextp) \
+  (__extension__ (__builtin_constant_p (sep) && __string2_1bptr_p (sep)	      \
+		  ? (((__const char *) (sep))[0] != '\0'		      \
+		     && ((__const char *) (sep))[1] == '\0'		      \
+		     ? __strtok_r_1c (s, ((__const char *) (sep))[0], nextp)  \
+		     : __strtok_r (s, sep, nextp))			      \
+		  : __strtok_r (s, sep, nextp)))
+# endif
+
+__STRING_INLINE char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
+__STRING_INLINE char *
+__strtok_r_1c (char *__s, char __sep, char **__nextp)
+{
+  char *__result;
+  if (__s == NULL)
+    __s = *__nextp;
+  while (*__s == __sep)
+    ++__s;
+  __result = NULL;
+  if (*__s != '\0')
+    {
+      __result = __s++;
+      while (*__s != '\0')
+	if (*__s++ == __sep)
+	  {
+	    __s[-1] = '\0';
+	    break;
+	  }
+      *__nextp = __s;
+    }
+  return __result;
+}
+# if defined __USE_POSIX || defined __USE_MISC
+#  define strtok_r(s, sep, nextp) __strtok_r (s, sep, nextp)
+# endif
+#endif
+
+
+#if !defined _HAVE_STRING_ARCH_strsep || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strsep
+
+extern char *__strsep_g (char **__stringp, __const char *__delim);
+#  define __strsep(s, reject) \
+  __extension__								      \
+  ({ char __r0, __r1, __r2;						      \
+     (__builtin_constant_p (reject) && __string2_1bptr_p (reject)	      \
+      && (__r0 = ((__const char *) (reject))[0],			      \
+	  ((__const char *) (reject))[0] != '\0')			      \
+      ? ((__r1 = ((__const char *) (reject))[1],			      \
+	 ((__const char *) (reject))[1] == '\0')			      \
+	 ? __strsep_1c (s, __r0)					      \
+	 : ((__r2 = ((__const char *) (reject))[2], __r2 == '\0')	      \
+	    ? __strsep_2c (s, __r0, __r1)				      \
+	    : (((__const char *) (reject))[3] == '\0'			      \
+	       ? __strsep_3c (s, __r0, __r1, __r2)			      \
+	       : __strsep_g (s, reject))))				      \
+      : __strsep_g (s, reject)); })
+# endif
+
+__STRING_INLINE char *__strsep_1c (char **__s, char __reject);
+__STRING_INLINE char *
+__strsep_1c (char **__s, char __reject)
+{
+  register char *__retval = *__s;
+  if (__retval != NULL && (*__s = strchr (__retval, __reject)) != NULL)
+    *(*__s)++ = '\0';
+  return __retval;
+}
+
+__STRING_INLINE char *__strsep_2c (char **__s, char __reject1, char __reject2);
+__STRING_INLINE char *
+__strsep_2c (char **__s, char __reject1, char __reject2)
+{
+  register char *__retval = *__s;
+  if (__retval != NULL)
+    {
+      register char *__cp = __retval;
+      while (1)
+	{
+	  if (*__cp == '\0')
+	    {
+	      __cp = NULL;
+	  break;
+	    }
+	  if (*__cp == __reject1 || *__cp == __reject2)
+	    {
+	      *__cp++ = '\0';
+	      break;
+	    }
+	  ++__cp;
+	}
+      *__s = __cp;
+    }
+  return __retval;
+}
+
+__STRING_INLINE char *__strsep_3c (char **__s, char __reject1, char __reject2,
+				   char __reject3);
+__STRING_INLINE char *
+__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
+{
+  register char *__retval = *__s;
+  if (__retval != NULL)
+    {
+      register char *__cp = __retval;
+      while (1)
+	{
+	  if (*__cp == '\0')
+	    {
+	      __cp = NULL;
+	  break;
+	    }
+	  if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
+	    {
+	      *__cp++ = '\0';
+	      break;
+	    }
+	  ++__cp;
+	}
+      *__s = __cp;
+    }
+  return __retval;
+}
+# ifdef __USE_BSD
+#  define strsep(s, reject) __strsep (s, reject)
+# endif
+#endif
+
+/* We need the memory allocation functions for inline strdup().
+   Referring to stdlib.h (even minimally) is not allowed
+   in any of the tight standards compliant modes.  */
+#ifdef __USE_MISC
+
+# if !defined _HAVE_STRING_ARCH_strdup || !defined _HAVE_STRING_ARCH_strndup
+#  define __need_malloc_and_calloc
+#  include <stdlib.h>
+# endif
+
+# ifndef _HAVE_STRING_ARCH_strdup
+
+extern char *__strdup (__const char *__string) __THROW __attribute_malloc__;
+#  define __strdup(s) \
+  (__extension__ (__builtin_constant_p (s) && __string2_1bptr_p (s)	      \
+		  ? (((__const char *) (s))[0] == '\0'			      \
+		     ? (char *) calloc (1, 1)				      \
+		     : ({ size_t __len = strlen (s) + 1;		      \
+			  char *__retval = (char *) malloc (__len);	      \
+			  if (__retval != NULL)				      \
+			    __retval = (char *) memcpy (__retval, s, __len);  \
+			  __retval; }))					      \
+		  : __strdup (s)))
+
+#  if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+#   define strdup(s) __strdup (s)
+#  endif
+# endif
+
+# ifndef _HAVE_STRING_ARCH_strndup
+
+extern char *__strndup (__const char *__string, size_t __n)
+     __THROW __attribute_malloc__;
+#  define __strndup(s, n) \
+  (__extension__ (__builtin_constant_p (s) && __string2_1bptr_p (s)	      \
+		  ? (((__const char *) (s))[0] == '\0'			      \
+		     ? (char *) calloc (1, 1)				      \
+		     : ({ size_t __len = strlen (s) + 1;		      \
+			  size_t __n = (n);				      \
+			  char *__retval;				      \
+			  if (__n < __len)				      \
+			    __len = __n + 1;				      \
+			  __retval = (char *) malloc (__len);		      \
+			  if (__retval != NULL)				      \
+			    {						      \
+			      __retval[__len - 1] = '\0';		      \
+			      __retval = (char *) memcpy (__retval, s,	      \
+							  __len - 1);	      \
+			    }						      \
+			  __retval; }))					      \
+		  : __strndup (s, n)))
+
+#  ifdef __USE_GNU
+#   define strndup(s, n) __strndup (s, n)
+#  endif
+# endif
+
+#endif /* Use misc. or use GNU.  */
+
+#ifndef _FORCE_INLINES
+# undef __STRING_INLINE
+#endif
+
+#endif /* No string inlines.  */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/bits/string.h hndtools-mipsel-uclibc-4.1.2.full/include/bits/string.h
--- hndtools-mipsel-uclibc-4.1.2/include/bits/string.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/bits/string.h	2002-03-01 23:46:02.000000000 +0300
@@ -0,0 +1,12 @@
+/* This file should provide inline versions of string functions.
+
+   Surround GCC-specific parts with #ifdef __GNUC__, and use `extern __inline'.
+
+   This file should define __STRING_INLINES if functions are actually defined
+   as inlines.  */
+
+#ifndef _BITS_STRING_H
+#define _BITS_STRING_H	1
+
+
+#endif /* bits/string.h */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/bits/stropts.h hndtools-mipsel-uclibc-4.1.2.full/include/bits/stropts.h
--- hndtools-mipsel-uclibc-4.1.2/include/bits/stropts.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/bits/stropts.h	2002-03-01 23:46:02.000000000 +0300
@@ -0,0 +1,227 @@
+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_STROPTS_H
+#define _BITS_STROPTS_H	1
+
+#include <bits/types.h>
+
+/* Macros used as `request' argument to `ioctl'.  */
+#define __SID		('S' << 8)
+
+#define I_NREAD	    (__SID | 1)	/* Counts the number of data bytes in the data
+				   block in the first message.  */
+#define I_PUSH	    (__SID | 2)	/* Push STREAMS module onto top of the current
+				   STREAM, just below the STREAM head.  */
+#define I_POP	    (__SID | 3)	/* Remove STREAMS module from just below the
+				   STREAM head.  */
+#define I_LOOK	    (__SID | 4)	/* Retrieve the name of the module just below
+				   the STREAM head and place it in a character
+				   string.  */
+#define I_FLUSH	    (__SID | 5)	/* Flush all input and/or output.  */
+#define I_SRDOPT    (__SID | 6)	/* Sets the read mode.  */
+#define I_GRDOPT    (__SID | 7)	/* Returns the current read mode setting.  */
+#define I_STR	    (__SID | 8)	/* Construct an internal STREAMS `ioctl'
+				   message and send that message downstream. */
+#define I_SETSIG    (__SID | 9)	/* Inform the STREAM head that the process
+				   wants the SIGPOLL signal issued.  */
+#define I_GETSIG    (__SID |10) /* Return the events for which the calling
+				   process is currently registered to be sent
+				   a SIGPOLL signal.  */
+#define I_FIND	    (__SID |11) /* Compares the names of all modules currently
+				   present in the STREAM to the name pointed to
+				   by `arg'.  */
+#define I_LINK	    (__SID |12) /* Connect two STREAMs.  */
+#define I_UNLINK    (__SID |13) /* Disconnects the two STREAMs.  */
+#define I_PEEK	    (__SID |15) /* Allows a process to retrieve the information
+				   in the first message on the STREAM head read
+				   queue without taking the message off the
+				   queue.  */
+#define I_FDINSERT  (__SID |16) /* Create a message from the specified
+				   buffer(s), adds information about another
+				   STREAM, and send the message downstream.  */
+#define I_SENDFD    (__SID |17) /* Requests the STREAM associated with `fildes'
+				   to send a message, containing a file
+				   pointer, to the STREAM head at the other end
+				   of a STREAMS pipe.  */
+#define I_RECVFD    (__SID |14) /* Non-EFT definition.  */
+#define I_SWROPT    (__SID |19) /* Set the write mode.  */
+#define I_GWROPT    (__SID |20) /* Return the current write mode setting.  */
+#define I_LIST	    (__SID |21) /* List all the module names on the STREAM, up
+				   to and including the topmost driver name. */
+#define I_PLINK	    (__SID |22) /* Connect two STREAMs with a persistent
+				   link.  */
+#define I_PUNLINK   (__SID |23) /* Disconnect the two STREAMs that were
+				   connected with a persistent link.  */
+#define I_FLUSHBAND (__SID |28) /* Flush only band specified.  */
+#define I_CKBAND    (__SID |29) /* Check if the message of a given priority
+				   band exists on the STREAM head read
+				   queue.  */
+#define I_GETBAND   (__SID |30) /* Return the priority band of the first
+				   message on the STREAM head read queue.  */
+#define I_ATMARK    (__SID |31) /* See if the current message on the STREAM
+				   head read queue is "marked" by some module
+				   downstream.  */
+#define I_SETCLTIME (__SID |32) /* Set the time the STREAM head will delay when
+				   a STREAM is closing and there is data on
+				   the write queues.  */
+#define I_GETCLTIME (__SID |33) /* Get current value for closing timeout.  */
+#define I_CANPUT    (__SID |34) /* Check if a certain band is writable.  */
+
+
+/* Used in `I_LOOK' request.  */
+#define FMNAMESZ	8	/* compatibility w/UnixWare/Solaris.  */
+
+/* Flush options.  */
+#define FLUSHR		0x01	/* Flush read queues.  */
+#define FLUSHW		0x02	/* Flush write queues.  */
+#define FLUSHRW		0x03	/* Flush read and write queues.  */
+#ifdef __USE_GNU
+# define FLUSHBAND	0x04	/* Flush only specified band.  */
+#endif
+
+/* Possible arguments for `I_SETSIG'.  */
+#define S_INPUT		0x0001	/* A message, other than a high-priority
+				   message, has arrived.  */
+#define S_HIPRI		0x0002	/* A high-priority message is present.  */
+#define S_OUTPUT	0x0004	/* The write queue for normal data is no longer
+				   full.  */
+#define S_MSG		0x0008	/* A STREAMS signal message that contains the
+				   SIGPOLL signal reaches the front of the
+				   STREAM head read queue.  */
+#define S_ERROR		0x0010	/* Notification of an error condition.  */
+#define S_HANGUP	0x0020	/* Notification of a hangup.  */
+#define S_RDNORM	0x0040	/* A normal message has arrived.  */
+#define S_WRNORM	S_OUTPUT
+#define S_RDBAND	0x0080	/* A message with a non-zero priority has
+				   arrived.  */
+#define S_WRBAND	0x0100	/* The write queue for a non-zero priority
+				   band is no longer full.  */
+#define S_BANDURG	0x0200	/* When used in conjunction with S_RDBAND,
+				   SIGURG is generated instead of SIGPOLL when
+				   a priority message reaches the front of the
+				   STREAM head read queue.  */
+
+/* Option for `I_PEEK'.  */
+#define RS_HIPRI	0x01	/* Only look for high-priority messages.  */
+
+/* Options for `I_SRDOPT'.  */
+#define RNORM		0x0000	/* Byte-STREAM mode, the default.  */
+#define RMSGD		0x0001	/* Message-discard mode.   */
+#define RMSGN		0x0002	/* Message-nondiscard mode.   */
+#define RPROTDAT	0x0004	/* Deliver the control part of a message as
+				   data.  */
+#define RPROTDIS	0x0008	/* Discard the control part of a message,
+				   delivering any data part.  */
+#define RPROTNORM	0x0010	/* Fail `read' with EBADMSG if a message
+				   containing a control part is at the front
+				   of the STREAM head read queue.  */
+#ifdef __USE_GNU
+# define RPROTMASK	0x001C	/* The RPROT bits */
+#endif
+
+/* Possible mode for `I_SWROPT'.  */
+#define SNDZERO		0x001	/* Send a zero-length message downstream when a
+				   `write' of 0 bytes occurs.  */
+#ifdef __USE_GNU
+# define SNDPIPE	0x002	/* Send SIGPIPE on write and putmsg if
+				   sd_werror is set.  */
+#endif
+
+/* Arguments for `I_ATMARK'.  */
+#define ANYMARK		0x01	/* Check if the message is marked.  */
+#define LASTMARK	0x02	/* Check if the message is the last one marked
+				   on the queue.  */
+
+/* Argument for `I_UNLINK'.  */
+#ifdef __USE_GNU
+# define MUXID_ALL	(-1)	/* Unlink all STREAMs linked to the STREAM
+				   associated with `fildes'.  */
+#endif
+
+
+/* Macros for `getmsg', `getpmsg', `putmsg' and `putpmsg'.  */
+#define MSG_HIPRI	0x01	/* Send/receive high priority message.  */
+#define MSG_ANY		0x02	/* Receive any message.  */
+#define MSG_BAND	0x04	/* Receive message from specified band.  */
+
+/* Values returned by getmsg and getpmsg */
+#define MORECTL		1	/* More control information is left in
+				   message.  */
+#define MOREDATA	2	/* More data is left in message.  */
+
+
+/* Structure used for the I_FLUSHBAND ioctl on streams.  */
+struct bandinfo
+  {
+    unsigned char bi_pri;
+    int bi_flag;
+  };
+
+struct strbuf
+  {
+    int maxlen;		/* Maximum buffer length.  */
+    int len;		/* Length of data.  */
+    char *buf;		/* Pointer to buffer.  */
+  };
+
+struct strpeek
+  {
+    struct strbuf ctlbuf;
+    struct strbuf databuf;
+    t_uscalar_t flags;			/* UnixWare/Solaris compatibility.  */
+  };
+
+struct strfdinsert
+  {
+    struct strbuf ctlbuf;
+    struct strbuf databuf;
+    t_uscalar_t flags;			/* UnixWare/Solaris compatibility.  */
+    int fildes;
+    int offset;
+  };
+
+struct strioctl
+  {
+    int ic_cmd;
+    int ic_timout;
+    int ic_len;
+    char *ic_dp;
+  };
+
+struct strrecvfd
+  {
+    int fd;
+    uid_t uid;
+    gid_t gid;
+    char __fill[8];			/* UnixWare/Solaris compatibility */
+  };
+
+
+struct str_mlist
+  {
+    char l_name[FMNAMESZ + 1];
+  };
+
+struct str_list
+  {
+    int sl_nmods;
+    struct str_mlist *sl_modlist;
+  };
+
+#endif /* bits/stropts.h */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/fstab.h hndtools-mipsel-uclibc-4.1.2.full/include/fstab.h
--- hndtools-mipsel-uclibc-4.1.2/include/fstab.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/fstab.h	2002-11-08 11:40:09.000000000 +0300
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 1980, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)fstab.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _FSTAB_H
+#define _FSTAB_H	1
+
+#include <features.h>
+
+/*
+ * File system table, see fstab(5).
+ *
+ * Used by dump, mount, umount, swapon, fsck, df, ...
+ *
+ * For ufs fs_spec field is the block special name.  Programs that want to
+ * use the character special name must create that name by prepending a 'r'
+ * after the right most slash.  Quota files are always named "quotas", so
+ * if type is "rq", then use concatenation of fs_file and "quotas" to locate
+ * quota file.
+ */
+#define	_PATH_FSTAB	"/etc/fstab"
+#define	FSTAB		"/etc/fstab"	/* deprecated */
+
+#define	FSTAB_RW	"rw"		/* read/write device */
+#define	FSTAB_RQ	"rq"		/* read/write with quotas */
+#define	FSTAB_RO	"ro"		/* read-only device */
+#define	FSTAB_SW	"sw"		/* swap device */
+#define	FSTAB_XX	"xx"		/* ignore totally */
+
+struct fstab
+  {
+    char *fs_spec;			/* block special device name */
+    char *fs_file;			/* file system path prefix */
+    char *fs_vfstype;			/* File system type, ufs, nfs */
+    char *fs_mntops;			/* Mount options ala -o */
+    const char *fs_type;		/* FSTAB_* from fs_mntops */
+    int	fs_freq;			/* dump frequency, in days */
+    int	fs_passno;			/* pass number on parallel dump */
+  };
+
+
+#if 0
+// Not yet implemented in uClibc
+__BEGIN_DECLS
+
+extern struct fstab *getfsent (void) __THROW;
+extern struct fstab *getfsspec (__const char *__name) __THROW;
+extern struct fstab *getfsfile (__const char *__name) __THROW;
+extern int setfsent (void) __THROW;
+extern void endfsent (void) __THROW;
+
+__END_DECLS
+#endif
+
+#endif /* fstab.h */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/net/pppio.h hndtools-mipsel-uclibc-4.1.2.full/include/net/pppio.h
--- hndtools-mipsel-uclibc-4.1.2/include/net/pppio.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/net/pppio.h	2001-09-27 09:21:12.000000000 +0400
@@ -0,0 +1,99 @@
+/*
+ * pppio.h - ioctl and other misc. definitions for STREAMS modules.
+ *
+ * Copyright (c) 1994 The Australian National University.
+ * All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, provided that the above copyright
+ * notice appears in all copies.  This software is provided without any
+ * warranty, express or implied. The Australian National University
+ * makes no representations about the suitability of this software for
+ * any purpose.
+ *
+ * IN NO EVENT SHALL THE AUSTRALIAN NATIONAL UNIVERSITY BE LIABLE TO ANY
+ * PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+ * THE AUSTRALIAN NATIONAL UNIVERSITY HAVE BEEN ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * THE AUSTRALIAN NATIONAL UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE AUSTRALIAN NATIONAL UNIVERSITY HAS NO
+ * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
+ * OR MODIFICATIONS.
+ *
+ * $Id: pppio.h,v 1.2 2001/09/27 05:21:12 andersen Exp $
+ */
+
+#define _PPPIO(n)	(('p' << 8) + (n))
+
+#define PPPIO_NEWPPA	_PPPIO(130)	/* allocate a new PPP unit */
+#define PPPIO_GETSTAT	_PPPIO(131)	/* get PPP statistics */
+#define PPPIO_GETCSTAT	_PPPIO(132)	/* get PPP compression stats */
+#define PPPIO_MTU	_PPPIO(133)	/* set max transmission unit */
+#define PPPIO_MRU	_PPPIO(134)	/* set max receive unit */
+#define PPPIO_CFLAGS	_PPPIO(135)	/* set/clear/get compression flags */
+#define PPPIO_XCOMP	_PPPIO(136)	/* alloc transmit compressor */
+#define PPPIO_RCOMP	_PPPIO(137)	/* alloc receive decompressor */
+#define PPPIO_XACCM	_PPPIO(138)	/* set transmit asyncmap */
+#define PPPIO_RACCM	_PPPIO(139)	/* set receive asyncmap */
+#define PPPIO_VJINIT	_PPPIO(140)	/* initialize VJ comp/decomp */
+#define PPPIO_ATTACH	_PPPIO(141)	/* attach to a ppa (without putmsg) */
+#define PPPIO_LASTMOD	_PPPIO(142)	/* mark last ppp module */
+#define PPPIO_GCLEAN	_PPPIO(143)	/* get 8-bit-clean flags */
+#define PPPIO_DEBUG	_PPPIO(144)	/* request debug information */
+#define PPPIO_BIND	_PPPIO(145)	/* bind to SAP */
+#define PPPIO_NPMODE	_PPPIO(146)	/* set mode for handling data pkts */
+#define PPPIO_GIDLE	_PPPIO(147)	/* get time since last data pkt */
+#define PPPIO_PASSFILT	_PPPIO(148)	/* set filter for packets to pass */
+#define PPPIO_ACTIVEFILT _PPPIO(149)	/* set filter for "link active" pkts */
+
+/*
+ * Values for PPPIO_CFLAGS
+ */
+#define COMP_AC		0x1		/* compress address/control */
+#define DECOMP_AC	0x2		/* decompress address/control */
+#define COMP_PROT	0x4		/* compress PPP protocol */
+#define DECOMP_PROT	0x8		/* decompress PPP protocol */
+
+#define COMP_VJC	0x10		/* compress TCP/IP headers */
+#define COMP_VJCCID	0x20		/* compress connection ID as well */
+#define DECOMP_VJC	0x40		/* decompress TCP/IP headers */
+#define DECOMP_VJCCID	0x80		/* accept compressed connection ID */
+
+#define CCP_ISOPEN	0x100		/* look at CCP packets */
+#define CCP_ISUP	0x200		/* do packet comp/decomp */
+#define CCP_ERROR	0x400		/* (status) error in packet decomp */
+#define CCP_FATALERROR	0x800		/* (status) fatal error ditto */
+#define CCP_COMP_RUN	0x1000		/* (status) seen CCP ack sent */
+#define CCP_DECOMP_RUN	0x2000		/* (status) seen CCP ack rcvd */
+
+/*
+ * Values for 8-bit-clean flags.
+ */
+#define RCV_B7_0	1		/* have rcvd char with bit 7 = 0 */
+#define RCV_B7_1	2		/* have rcvd char with bit 7 = 1 */
+#define RCV_EVNP	4		/* have rcvd char with even parity */
+#define RCV_ODDP	8		/* have rcvd char with odd parity */
+
+/*
+ * Values for the first byte of M_CTL messages passed between
+ * PPP modules.
+ */
+#define PPPCTL_OERROR	0xe0		/* output error [up] */
+#define PPPCTL_IERROR	0xe1		/* input error (e.g. FCS) [up] */
+#define PPPCTL_MTU	0xe2		/* set MTU [down] */
+#define PPPCTL_MRU	0xe3		/* set MRU [down] */
+#define PPPCTL_UNIT	0xe4		/* note PPP unit number [down] */
+
+/*
+ * Values for the integer argument to PPPIO_DEBUG.
+ */
+#define PPPDBG_DUMP	0x10000		/* print out debug info now */
+#define PPPDBG_LOG	0x100		/* log various things */
+#define PPPDBG_DRIVER	0		/* identifies ppp driver as target */
+#define PPPDBG_IF	1		/* identifies ppp network i/f target */
+#define PPPDBG_COMP	2		/* identifies ppp compression target */
+#define PPPDBG_AHDLC	3		/* identifies ppp async hdlc target */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/net/slcompress.h hndtools-mipsel-uclibc-4.1.2.full/include/net/slcompress.h
--- hndtools-mipsel-uclibc-4.1.2/include/net/slcompress.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/net/slcompress.h	2001-09-27 09:21:12.000000000 +0400
@@ -0,0 +1,148 @@
+/*
+ * Definitions for tcp compression routines.
+ *
+ * $Id: slcompress.h,v 1.3 2001/09/27 05:21:12 andersen Exp $
+ *
+ * Copyright (c) 1989 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:
+ *	- Initial distribution.
+ */
+
+#ifndef _SLCOMPRESS_H_
+#define _SLCOMPRESS_H_
+
+#define MAX_STATES 16		/* must be > 2 and < 256 */
+#define MAX_HDR MLEN		/* XXX 4bsd-ism: should really be 128 */
+
+/*
+ * Compressed packet format:
+ *
+ * The first octet contains the packet type (top 3 bits), TCP
+ * 'push' bit, and flags that indicate which of the 4 TCP sequence
+ * numbers have changed (bottom 5 bits).  The next octet is a
+ * conversation number that associates a saved IP/TCP header with
+ * the compressed packet.  The next two octets are the TCP checksum
+ * from the original datagram.  The next 0 to 15 octets are
+ * sequence number changes, one change per bit set in the header
+ * (there may be no changes and there are two special cases where
+ * the receiver implicitly knows what changed -- see below).
+ * 
+ * There are 5 numbers which can change (they are always inserted
+ * in the following order): TCP urgent pointer, window,
+ * acknowlegement, sequence number and IP ID.  (The urgent pointer
+ * is different from the others in that its value is sent, not the
+ * change in value.)  Since typical use of SLIP links is biased
+ * toward small packets (see comments on MTU/MSS below), changes
+ * use a variable length coding with one octet for numbers in the
+ * range 1 - 255 and 3 octets (0, MSB, LSB) for numbers in the
+ * range 256 - 65535 or 0.  (If the change in sequence number or
+ * ack is more than 65535, an uncompressed packet is sent.)
+ */
+
+/*
+ * Packet types (must not conflict with IP protocol version)
+ *
+ * The top nibble of the first octet is the packet type.  There are
+ * three possible types: IP (not proto TCP or tcp with one of the
+ * control flags set); uncompressed TCP (a normal IP/TCP packet but
+ * with the 8-bit protocol field replaced by an 8-bit connection id --
+ * this type of packet syncs the sender & receiver); and compressed
+ * TCP (described above).
+ *
+ * LSB of 4-bit field is TCP "PUSH" bit (a worthless anachronism) and
+ * is logically part of the 4-bit "changes" field that follows.  Top
+ * three bits are actual packet type.  For backward compatibility
+ * and in the interest of conserving bits, numbers are chosen so the
+ * IP protocol version number (4) which normally appears in this nibble
+ * means "IP packet".
+ */
+
+/* packet types */
+#define TYPE_IP 0x40
+#define TYPE_UNCOMPRESSED_TCP 0x70
+#define TYPE_COMPRESSED_TCP 0x80
+#define TYPE_ERROR 0x00
+
+/* Bits in first octet of compressed packet */
+#define NEW_C	0x40	/* flag bits for what changed in a packet */
+#define NEW_I	0x20
+#define NEW_S	0x08
+#define NEW_A	0x04
+#define NEW_W	0x02
+#define NEW_U	0x01
+
+/* reserved, special-case values of above */
+#define SPECIAL_I (NEW_S|NEW_W|NEW_U)		/* echoed interactive traffic */
+#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)	/* unidirectional data */
+#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)
+
+#define TCP_PUSH_BIT 0x10
+
+
+/*
+ * "state" data for each active tcp conversation on the wire.  This is
+ * basically a copy of the entire IP/TCP header from the last packet
+ * we saw from the conversation together with a small identifier
+ * the transmit & receive ends of the line use to locate saved header.
+ */
+struct cstate {
+	struct cstate *cs_next;	/* next most recently used cstate (xmit only) */
+	u_short cs_hlen;	/* size of hdr (receive only) */
+	u_char cs_id;		/* connection # associated with this state */
+	u_char cs_filler;
+	union {
+		char csu_hdr[MAX_HDR];
+		struct ip csu_ip;	/* ip/tcp hdr from most recent packet */
+	} slcs_u;
+};
+#define cs_ip slcs_u.csu_ip
+#define cs_hdr slcs_u.csu_hdr
+
+/*
+ * all the state data for one serial line (we need one of these
+ * per line).
+ */
+struct slcompress {
+	struct cstate *last_cs;	/* most recently used tstate */
+	u_char last_recv;	/* last rcvd conn. id */
+	u_char last_xmit;	/* last sent conn. id */
+	u_short flags;
+#ifndef SL_NO_STATS
+	int sls_packets;	/* outbound packets */
+	int sls_compressed;	/* outbound compressed packets */
+	int sls_searches;	/* searches for connection state */
+	int sls_misses;		/* times couldn't find conn. state */
+	int sls_uncompressedin;	/* inbound uncompressed packets */
+	int sls_compressedin;	/* inbound compressed packets */
+	int sls_errorin;	/* inbound unknown type packets */
+	int sls_tossed;		/* inbound packets tossed because of error */
+#endif
+	struct cstate tstate[MAX_STATES];	/* xmit connection states */
+	struct cstate rstate[MAX_STATES];	/* receive connection states */
+};
+/* flag values */
+#define SLF_TOSS 1		/* tossing rcvd frames because of input err */
+
+void	sl_compress_init __P((struct slcompress *));
+void	sl_compress_setup __P((struct slcompress *, int));
+u_int	sl_compress_tcp __P((struct mbuf *,
+	    struct ip *, struct slcompress *, int));
+int	sl_uncompress_tcp __P((u_char **, int, u_int, struct slcompress *));
+int	sl_uncompress_tcp_core __P((u_char *, int, int, u_int,
+	    struct slcompress *, u_char **, u_int *));
+
+#endif /* _SLCOMPRESS_H_ */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/net/vjcompress.h hndtools-mipsel-uclibc-4.1.2.full/include/net/vjcompress.h
--- hndtools-mipsel-uclibc-4.1.2/include/net/vjcompress.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/net/vjcompress.h	2001-09-27 09:21:12.000000000 +0400
@@ -0,0 +1,144 @@
+/*
+ * Definitions for tcp compression routines.
+ *
+ * $Id: vjcompress.h,v 1.3 2001/09/27 05:21:12 andersen Exp $
+ *
+ * Copyright (c) 1989 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:
+ *	- Initial distribution.
+ */
+
+#ifndef _VJCOMPRESS_H_
+#define _VJCOMPRESS_H_
+
+#define MAX_STATES 16		/* must be > 2 and < 256 */
+#define MAX_HDR	   128
+
+/*
+ * Compressed packet format:
+ *
+ * The first octet contains the packet type (top 3 bits), TCP
+ * 'push' bit, and flags that indicate which of the 4 TCP sequence
+ * numbers have changed (bottom 5 bits).  The next octet is a
+ * conversation number that associates a saved IP/TCP header with
+ * the compressed packet.  The next two octets are the TCP checksum
+ * from the original datagram.  The next 0 to 15 octets are
+ * sequence number changes, one change per bit set in the header
+ * (there may be no changes and there are two special cases where
+ * the receiver implicitly knows what changed -- see below).
+ * 
+ * There are 5 numbers which can change (they are always inserted
+ * in the following order): TCP urgent pointer, window,
+ * acknowlegement, sequence number and IP ID.  (The urgent pointer
+ * is different from the others in that its value is sent, not the
+ * change in value.)  Since typical use of SLIP links is biased
+ * toward small packets (see comments on MTU/MSS below), changes
+ * use a variable length coding with one octet for numbers in the
+ * range 1 - 255 and 3 octets (0, MSB, LSB) for numbers in the
+ * range 256 - 65535 or 0.  (If the change in sequence number or
+ * ack is more than 65535, an uncompressed packet is sent.)
+ */
+
+/*
+ * Packet types (must not conflict with IP protocol version)
+ *
+ * The top nibble of the first octet is the packet type.  There are
+ * three possible types: IP (not proto TCP or tcp with one of the
+ * control flags set); uncompressed TCP (a normal IP/TCP packet but
+ * with the 8-bit protocol field replaced by an 8-bit connection id --
+ * this type of packet syncs the sender & receiver); and compressed
+ * TCP (described above).
+ *
+ * LSB of 4-bit field is TCP "PUSH" bit (a worthless anachronism) and
+ * is logically part of the 4-bit "changes" field that follows.  Top
+ * three bits are actual packet type.  For backward compatibility
+ * and in the interest of conserving bits, numbers are chosen so the
+ * IP protocol version number (4) which normally appears in this nibble
+ * means "IP packet".
+ */
+
+/* packet types */
+#define TYPE_IP 0x40
+#define TYPE_UNCOMPRESSED_TCP 0x70
+#define TYPE_COMPRESSED_TCP 0x80
+#define TYPE_ERROR 0x00
+
+/* Bits in first octet of compressed packet */
+#define NEW_C	0x40	/* flag bits for what changed in a packet */
+#define NEW_I	0x20
+#define NEW_S	0x08
+#define NEW_A	0x04
+#define NEW_W	0x02
+#define NEW_U	0x01
+
+/* reserved, special-case values of above */
+#define SPECIAL_I (NEW_S|NEW_W|NEW_U)		/* echoed interactive traffic */
+#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)	/* unidirectional data */
+#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)
+
+#define TCP_PUSH_BIT 0x10
+
+
+/*
+ * "state" data for each active tcp conversation on the wire.  This is
+ * basically a copy of the entire IP/TCP header from the last packet
+ * we saw from the conversation together with a small identifier
+ * the transmit & receive ends of the line use to locate saved header.
+ */
+struct cstate {
+    struct cstate *cs_next;	/* next most recently used state (xmit only) */
+    u_short cs_hlen;		/* size of hdr (receive only) */
+    u_char cs_id;		/* connection # associated with this state */
+    u_char cs_filler;
+    union {
+	char csu_hdr[MAX_HDR];
+	struct ip csu_ip;	/* ip/tcp hdr from most recent packet */
+    } vjcs_u;
+};
+#define cs_ip vjcs_u.csu_ip
+#define cs_hdr vjcs_u.csu_hdr
+
+/*
+ * all the state data for one serial line (we need one of these per line).
+ */
+struct vjcompress {
+    struct cstate *last_cs;	/* most recently used tstate */
+    u_char last_recv;		/* last rcvd conn. id */
+    u_char last_xmit;		/* last sent conn. id */
+    u_short flags;
+#ifndef VJ_NO_STATS
+    struct vjstat stats;
+#endif
+    struct cstate tstate[MAX_STATES];	/* xmit connection states */
+    struct cstate rstate[MAX_STATES];	/* receive connection states */
+};
+
+/* flag values */
+#define VJF_TOSS 1		/* tossing rcvd frames because of input err */
+
+extern void  vj_compress_init __P((struct vjcompress *comp, int max_state));
+extern u_int vj_compress_tcp __P((struct ip *ip, u_int mlen,
+				struct vjcompress *comp, int compress_cid_flag,
+				u_char **vjhdrp));
+extern void  vj_uncompress_err __P((struct vjcompress *comp));
+extern int   vj_uncompress_uncomp __P((u_char *buf, int buflen,
+				struct vjcompress *comp));
+extern int   vj_uncompress_tcp __P((u_char *buf, int buflen, int total_len,
+				struct vjcompress *comp, u_char **hdrp,
+				u_int *hlenp));
+
+#endif /* _VJCOMPRESS_H_ */
diff -urBN hndtools-mipsel-uclibc-4.1.2/include/stropts.h hndtools-mipsel-uclibc-4.1.2.full/include/stropts.h
--- hndtools-mipsel-uclibc-4.1.2/include/stropts.h	1970-01-01 03:00:00.000000000 +0300
+++ hndtools-mipsel-uclibc-4.1.2.full/include/stropts.h	2002-07-10 08:15:31.000000000 +0400
@@ -0,0 +1,81 @@
+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STROPTS_H
+#define _STROPTS_H	1
+
+#include <features.h>
+#include <bits/types.h>
+
+#ifndef __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+#ifndef __uid_t_defined
+typedef __uid_t uid_t;
+# define __uid_t_defined
+#endif
+
+typedef __t_uscalar_t t_uscalar_t;
+
+/* Get system specific contants.  */
+#include <bits/stropts.h>
+
+
+__BEGIN_DECLS
+
+/* Test whether FILDES is associated with a STREAM-based file.  */
+extern int isastream (int __fildes) __THROW;
+
+/* Receive next message from a STREAMS file.  */
+extern int getmsg (int __fildes, struct strbuf *__restrict __ctlptr,
+		   struct strbuf *__restrict __dataptr,
+		   int *__restrict __flagsp) __THROW;
+
+/* Receive next message from a STREAMS file, with *FLAGSP allowing to
+   control which message.  */
+extern int getpmsg (int __fildes, struct strbuf *__restrict __ctlptr,
+		    struct strbuf *__restrict __dataptr,
+		    int *__restrict __bandp, int *__restrict __flagsp)
+     __THROW;
+
+/* Perform the I/O control operation specified by REQUEST on FD.
+   One argument may follow; its presence and type depend on REQUEST.
+   Return value depends on REQUEST.  Usually -1 indicates error.  */
+extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
+
+/* Send a message on a STREAM.  */
+extern int putmsg (int __fildes, __const struct strbuf *__ctlptr,
+		   __const struct strbuf *__dataptr, int __flags) __THROW;
+
+/* Send a message on a STREAM to the BAND.  */
+extern int putpmsg (int __fildes, __const struct strbuf *__ctlptr,
+		    __const struct strbuf *__dataptr, int __band, int __flags)
+     __THROW;
+
+/* Attach a STREAMS-based file descriptor FILDES to a file PATH in the
+   file system name space.  */
+extern int fattach (int __fildes, __const char *__path) __THROW;
+
+/* Detach a name PATH from a STREAMS-based file descriptor.  */
+extern int fdetach (__const char *__path) __THROW;
+
+__END_DECLS
+
+#endif /* stropts.h */
