Add eventfd(eventfd2) support. Also, provide eventfd_read() and eventfd_write() glibc extensions.

---
 e118373cbb58ba5ffa5fb6670957678d5b87cdb9 eventfd: Implement eventfd2 and fix eventfd
---

 libc/sysdeps/linux/common/Makefile.in   |    2 -
 libc/sysdeps/linux/common/eventfd.c     |   63 ++++++++++++++++++++++++++++++++
 libc/sysdeps/linux/common/sys/eventfd.h |   58 +++++++++++++++++++++++++++++
 3 files changed, 122 insertions(+), 1 deletion(-)
 create mode 100644 libc/sysdeps/linux/common/eventfd.c
 create mode 100644 libc/sysdeps/linux/common/sys/eventfd.h

diff --git a/libc/sysdeps/linux/common/Makefile.in b/libc/sysdeps/linux/common/Makefile.in
--- a/libc/sysdeps/linux/common/Makefile.in
+++ b/libc/sysdeps/linux/common/Makefile.in
@@ -24,7 +24,7 @@ CSRC-$(UCLIBC_LINUX_SPECIFIC) += capget.c capset.c inotify.c ioperm.c iopl.c \
 	remap_file_pages.c sched_getaffinity.c sched_setaffinity.c \
 	sendfile64.c sendfile.c setfsgid.c setfsuid.c setresuid.c \
 	splice.c vmsplice.c tee.c signalfd.c swapoff.c swapon.c \
-	sync_file_range.c sysctl.c sysinfo.c timerfd.c unshare.c \
+	sync_file_range.c sysctl.c sysinfo.c eventfd.c timerfd.c unshare.c \
 	uselib.c vhangup.c
 # NPTL needs these internally: madvise.c
 CSRC-$(findstring y,$(UCLIBC_LINUX_SPECIFIC)$(UCLIBC_HAS_THREADS_NATIVE)) += madvise.c
diff --git a/libc/sysdeps/linux/common/eventfd.c b/libc/sysdeps/linux/common/eventfd.c
new file mode 100644
--- /dev/null
+++ b/libc/sysdeps/linux/common/eventfd.c
@@ -0,0 +1,63 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * eventfd() for uClibc
+ *
+ * Copyright (C) 2011 Jean-Christian de Rivaz <jc at eclis.ch>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <sys/eventfd.h>
+
+/*
+ * eventfd()
+ */
+#if defined __NR_eventfd || defined __NR_eventfd2
+int eventfd (int count, int flags)
+{
+  int res;
+  INTERNAL_SYSCALL_DECL (err);
+
+#if defined __NR_eventfd2
+  res = INTERNAL_SYSCALL (eventfd2, err, 2, count, flags);
+  if (likely(!INTERNAL_SYSCALL_ERROR_P (res, err)))
+    return res;
+
+  if (INTERNAL_SYSCALL_ERRNO (res, err) != ENOSYS) {
+    __set_errno (INTERNAL_SYSCALL_ERRNO (res, err));
+    return -1;
+  }
+#endif
+  /* The old system call has no flag parameter which is bad. */
+  if (flags != 0) {
+    __set_errno (EINVAL);
+    return -1;
+  }
+#if defined __NR_eventfd
+  res = INTERNAL_SYSCALL (eventfd, err, 1, count);
+  if (likely(!INTERNAL_SYSCALL_ERROR_P (res, err)))
+    return res;
+
+  __set_errno (INTERNAL_SYSCALL_ERRNO (res, err));
+#else
+  __set_errno (ENOSYS);
+#endif
+  return -1;
+}
+
+int
+eventfd_read (int fd, eventfd_t *value)
+{
+  return read (fd, value, sizeof (eventfd_t)) != sizeof (eventfd_t) ? -1 : 0;
+}
+
+int
+eventfd_write (int fd, eventfd_t value)
+{
+  return write (fd, &value,
+		sizeof (eventfd_t)) != sizeof (eventfd_t) ? -1 : 0;
+}
+#endif
diff --git a/libc/sysdeps/linux/common/sys/eventfd.h b/libc/sysdeps/linux/common/sys/eventfd.h
new file mode 100644
--- /dev/null
+++ b/libc/sysdeps/linux/common/sys/eventfd.h
@@ -0,0 +1,58 @@
+/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EVENTFD_H
+#define	_SYS_EVENTFD_H	1
+
+#include <stdint.h>
+
+
+/* Type for event counter.  */
+typedef uint64_t eventfd_t;
+
+/* Flags for signalfd.  */
+enum
+  {
+    EFD_SEMAPHORE = 1,
+#define EFD_SEMAPHORE EFD_SEMAPHORE
+    EFD_CLOEXEC = 02000000,
+#define EFD_CLOEXEC EFD_CLOEXEC
+#if defined __mips__
+    EFD_NONBLOCK = 00000200
+#else
+    EFD_NONBLOCK = 00004000
+#endif
+#define EFD_NONBLOCK EFD_NONBLOCK
+  };
+
+
+__BEGIN_DECLS
+
+/* Return file descriptor for generic event channel.  Set initial
+   value to COUNT.  */
+extern int eventfd (int __count, int __flags) __THROW;
+
+/* Read event counter and possibly wait for events.  */
+extern int eventfd_read (int __fd, eventfd_t *__value);
+
+/* Increment event counter.  */
+extern int eventfd_write (int __fd, eventfd_t __value);
+
+__END_DECLS
+
+#endif /* sys/eventfd.h */
-- 
