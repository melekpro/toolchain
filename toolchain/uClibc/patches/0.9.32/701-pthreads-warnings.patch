From 1f9808dbf74fb771f6a631a4f37a2f2c3b9e4643
From: Peter S. Mazinger
Date: Sun, 20 Mar 2011 01:38:48 +0000
Subject: [future] fix a bunch of build warnings

Added attribute_noreturn even if it has return at the end of function

Signed-off-by: Peter S. Mazinger <ps.m@gmx.net>
---
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index bd56500..c03f03a 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -2994,7 +2994,7 @@ int res_init(void)
 libc_hidden_def(res_init)
 
 #ifdef __UCLIBC_HAS_BSD_RES_CLOSE__
-void res_close(void)
+void attribute_noreturn res_close(void)
 {
 	__UCLIBC_MUTEX_LOCK(__resolv_lock);
 	__close_nameservers();
@@ -3012,7 +3012,9 @@ void res_close(void)
 	}
 #endif
 	memset(&_res, 0, sizeof(_res));
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	/* the loop is only to make gcc happy */
+	while(1)
+		__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
 }
 #endif
 
diff --git a/libpthread/nptl/cleanup_routine.c b/libpthread/nptl/cleanup_routine.c
index cbf2318..54badf0 100644
--- a/libpthread/nptl/cleanup_routine.c
+++ b/libpthread/nptl/cleanup_routine.c
@@ -19,7 +19,7 @@
 
 #include <pthread.h>
 
-
+void __pthread_cleanup_routine (struct __pthread_cleanup_frame *f);
 void
 __pthread_cleanup_routine (struct __pthread_cleanup_frame *f)
 {
diff --git a/libpthread/nptl/pt-cleanup.c b/libpthread/nptl/pt-cleanup.c
index d7394ae..aa0b9bb 100644
--- a/libpthread/nptl/pt-cleanup.c
+++ b/libpthread/nptl/pt-cleanup.c
@@ -23,7 +23,7 @@
 #include <jmpbuf-unwind.h>
 
 void
-attribute_protected
+/*does not apply due to hidden_proto(): attribute_protected*/
 __pthread_cleanup_upto (__jmp_buf target, char *targetframe)
 {
   struct pthread *self = THREAD_SELF;
diff --git a/libpthread/nptl/pthread_create.c b/libpthread/nptl/pthread_create.c
index e9492df..a2764a0 100644
--- a/libpthread/nptl/pthread_create.c
+++ b/libpthread/nptl/pthread_create.c
@@ -221,7 +221,7 @@ __free_tcb (struct pthread *pd)
 }
 
 
-static int
+static int attribute_noreturn
 start_thread (void *arg)
 {
   struct pthread *pd = (struct pthread *) arg;
diff --git a/libpthread/nptl/pthread_exit.c b/libpthread/nptl/pthread_exit.c
index 88d3859..98f67f2 100644
--- a/libpthread/nptl/pthread_exit.c
+++ b/libpthread/nptl/pthread_exit.c
@@ -22,7 +22,7 @@
 
 
 void
-attribute_protected
+attribute_protected attribute_noreturn
 __pthread_exit (void* value)
 {
   THREAD_SETMEM (THREAD_SELF, result, value);
diff --git a/libpthread/nptl/pthread_getspecific.c b/libpthread/nptl/pthread_getspecific.c
index 639a4fd..a00fe0b 100644
--- a/libpthread/nptl/pthread_getspecific.c
+++ b/libpthread/nptl/pthread_getspecific.c
@@ -21,8 +21,8 @@
 #include "pthreadP.h"
 
 
-void *
 attribute_protected
+void *
 __pthread_getspecific (pthread_key_t key)
 {
   struct pthread_key_data *data;
diff --git a/libpthread/nptl/sysdeps/pthread/pthread.h b/libpthread/nptl/sysdeps/pthread/pthread.h
index deb7430..e94cabb 100644
--- a/libpthread/nptl/sysdeps/pthread/pthread.h
+++ b/libpthread/nptl/sysdeps/pthread/pthread.h
@@ -581,6 +581,7 @@ class __pthread_cleanup_class
    function the compiler is free to decide inlining the change when
    needed or fall back on the copy which must exist somewhere
    else.  */
+void __pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame);
 __extern_inline void
 __pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)
 {
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c b/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c
index 188040e..91d40a3 100644
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c
@@ -111,7 +111,7 @@ notification_function (void *arg)
 
 
 /* Helper thread.  */
-static void *
+static attribute_noreturn void *
 helper_thread (void *arg)
 {
   while (1)
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c b/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c
index 4319d8d..1664af5 100644
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c
@@ -69,7 +69,7 @@ timer_sigev_thread (void *arg)
 
 
 /* Helper function to support starting threads for SIGEV_THREAD.  */
-static void *
+static attribute_noreturn void *
 timer_helper_thread (void *arg)
 {
   /* Wait for the SIGTIMER signal, allowing the setXid signal, and
diff --git a/libpthread/nptl/unwind.c b/libpthread/nptl/unwind.c
index 671d702..3952885 100644
--- a/libpthread/nptl/unwind.c
+++ b/libpthread/nptl/unwind.c
@@ -99,7 +99,7 @@ unwind_stop (int version, _Unwind_Action actions,
 }
 
 
-static void
+static attribute_noreturn void
 unwind_cleanup (_Unwind_Reason_Code reason, struct _Unwind_Exception *exc)
 {
   /* When we get here a C++ catch block didn't rethrow the object.  We
@@ -115,7 +115,7 @@ unwind_cleanup (_Unwind_Reason_Code reason, struct _Unwind_Exception *exc)
 
 
 void
-attribute_protected
+/*does not apply due to hidden_proto(): attribute_protected*/
 __cleanup_fct_attribute __attribute ((noreturn))
 #if !defined SHARED && !defined IS_IN_libpthread
 weak_function
--
cgit v0.9.0.1-2-gef13
