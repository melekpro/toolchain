From 1f9808dbf74fb771f6a631a4f37a2f2c3b9e4643
From: Peter S. Mazinger
Date: Sun, 20 Mar 2011 01:38:48 +0000
Subject: [future] fix a bunch of build warnings

Added attribute_noreturn even if it has return at the end of function

Signed-off-by: Peter S. Mazinger <ps.m@gmx.net>

---
From 293173f87072bbc0cafc457d5d8a6039f4d1d259
From: Peter S. Mazinger
Date: Sun, 20 Mar 2011 01:21:38 +0000
Subject: pthreadP.h: avoid shadow warnings

Change CANCELLATION_P macro and adapt usage.

Signed-off-by: Peter S. Mazinger <ps.m@gmx.net>
Signed-off-by: Bernhard Reutner-Fischer <rep.dot.nop@gmail.com>

---
From 77937735ab0b3cc45c02cce1a4e4b57acbb344cc
From: Carmelo Amoroso
Date: Wed, 14 Mar 2012 15:26:13 +0000
Subject: nptl: fix compiler warning due to missing prototype

libpthread/nptl/sysdeps/pthread/pt-longjmp.c: In function 'longjmp':
libpthread/nptl/sysdeps/pthread/pt-longjmp.c:27:3: warning: implicit declaration of function '__libc_longjmp' [-Wimplicit-function-declaration]
libpthread/nptl/sysdeps/pthread/pt-longjmp.c:28:1: warning: 'noreturn' function does return [enabled by default]

Signed-off-by: Carmelo Amoroso <carmelo.amoroso@st.com>

---
From 2d9740a65a81fe050f99479c2a2f38b6a3198a8e
From: Tony Wu
Date: Fri, 25 Jul 2014 05:52:11 +0000
Subject: uclibc: nptl: fix __lll_lock_wait_private multiple definition

Mark non-pthread __lll_lock_wait_private weak to avoid multiple
definition error in static link mode.

Signed-off-by: Tony Wu <tung7970@gmail.com>
Signed-off-by: Bernhard Reutner-Fischer <rep.dot.nop@gmail.com>
---

diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -2994,7 +2994,7 @@ int res_init(void)
 libc_hidden_def(res_init)
 
 #ifdef __UCLIBC_HAS_BSD_RES_CLOSE__
-void res_close(void)
+void attribute_noreturn res_close(void)
 {
 	__UCLIBC_MUTEX_LOCK(__resolv_lock);
 	__close_nameservers();
@@ -3012,7 +3012,9 @@ void res_close(void)
 	}
 #endif
 	memset(&_res, 0, sizeof(_res));
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	/* the loop is only to make gcc happy */
+	while(1)
+		__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
 }
 #endif
 
diff --git a/libc/unistd/sleep.c b/libc/unistd/sleep.c
--- a/libc/unistd/sleep.c
+++ b/libc/unistd/sleep.c
@@ -99,6 +99,7 @@ unsigned int sleep (unsigned int seconds)
     /* This is not necessary but some buggy programs depend on this.  */
     if (seconds == 0) {
 #  ifdef CANCELLATION_P
+	int cancelhandling;
 	CANCELLATION_P (THREAD_SELF);
 #  endif
 	return 0;
diff --git a/libpthread/nptl/cleanup_routine.c b/libpthread/nptl/cleanup_routine.c
--- a/libpthread/nptl/cleanup_routine.c
+++ b/libpthread/nptl/cleanup_routine.c
@@ -19,7 +19,7 @@
 
 #include <pthread.h>
 
-
+void __pthread_cleanup_routine (struct __pthread_cleanup_frame *f);
 void
 __pthread_cleanup_routine (struct __pthread_cleanup_frame *f)
 {
diff --git a/libpthread/nptl/pt-cleanup.c b/libpthread/nptl/pt-cleanup.c
--- a/libpthread/nptl/pt-cleanup.c
+++ b/libpthread/nptl/pt-cleanup.c
@@ -23,7 +23,7 @@
 #include <jmpbuf-unwind.h>
 
 void
-attribute_protected
+/*does not apply due to hidden_proto(): attribute_protected*/
 __pthread_cleanup_upto (__jmp_buf target, char *targetframe)
 {
   struct pthread *self = THREAD_SELF;
diff --git a/libpthread/nptl/pthreadP.h b/libpthread/nptl/pthreadP.h
--- a/libpthread/nptl/pthreadP.h
+++ b/libpthread/nptl/pthreadP.h
@@ -221,7 +221,7 @@ extern int __pthread_debug attribute_hidden;
 /* Cancellation test.  */
 #define CANCELLATION_P(self) \
   do {									      \
-    int cancelhandling = THREAD_GETMEM (self, cancelhandling);		      \
+    cancelhandling = THREAD_GETMEM (self, cancelhandling);		      \
     if (CANCEL_ENABLED_AND_CANCELED (cancelhandling))			      \
       {									      \
 	THREAD_SETMEM (self, result, PTHREAD_CANCELED);			      \
diff --git a/libpthread/nptl/pthread_create.c b/libpthread/nptl/pthread_create.c
--- a/libpthread/nptl/pthread_create.c
+++ b/libpthread/nptl/pthread_create.c
@@ -221,7 +221,7 @@ __free_tcb (struct pthread *pd)
 }
 
 
-static int
+static int attribute_noreturn
 start_thread (void *arg)
 {
   struct pthread *pd = (struct pthread *) arg;
diff --git a/libpthread/nptl/pthread_exit.c b/libpthread/nptl/pthread_exit.c
--- a/libpthread/nptl/pthread_exit.c
+++ b/libpthread/nptl/pthread_exit.c
@@ -22,7 +22,7 @@
 
 
 void
-attribute_protected
+attribute_protected attribute_noreturn
 __pthread_exit (void* value)
 {
   THREAD_SETMEM (THREAD_SELF, result, value);
diff --git a/libpthread/nptl/pthread_getspecific.c b/libpthread/nptl/pthread_getspecific.c
--- a/libpthread/nptl/pthread_getspecific.c
+++ b/libpthread/nptl/pthread_getspecific.c
@@ -21,8 +21,8 @@
 #include "pthreadP.h"
 
 
-void *
 attribute_protected
+void *
 __pthread_getspecific (pthread_key_t key)
 {
   struct pthread_key_data *data;
diff --git a/libpthread/nptl/pthread_testcancel.c b/libpthread/nptl/pthread_testcancel.c
--- a/libpthread/nptl/pthread_testcancel.c
+++ b/libpthread/nptl/pthread_testcancel.c
@@ -24,5 +24,6 @@
 void
 pthread_testcancel (void)
 {
+  int cancelhandling;
   CANCELLATION_P (THREAD_SELF);
 }
diff --git a/libpthread/nptl/sysdeps/pthread/pt-longjmp.c b/libpthread/nptl/sysdeps/pthread/pt-longjmp.c
--- a/libpthread/nptl/sysdeps/pthread/pt-longjmp.c
+++ b/libpthread/nptl/sysdeps/pthread/pt-longjmp.c
@@ -21,6 +21,8 @@
 #include <stdlib.h>
 #include "pthreadP.h"
 
+extern __typeof(longjmp) __libc_longjmp attribute_noreturn;
+
 void
 longjmp (jmp_buf env, int val)
 {
diff --git a/libpthread/nptl/sysdeps/pthread/pthread.h b/libpthread/nptl/sysdeps/pthread/pthread.h
--- a/libpthread/nptl/sysdeps/pthread/pthread.h
+++ b/libpthread/nptl/sysdeps/pthread/pthread.h
@@ -581,6 +581,7 @@ class __pthread_cleanup_class
    function the compiler is free to decide inlining the change when
    needed or fall back on the copy which must exist somewhere
    else.  */
+void __pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame);
 __extern_inline void
 __pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)
 {
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/arm/lowlevellock.c b/libpthread/nptl/sysdeps/unix/sysv/linux/arm/lowlevellock.c
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/arm/lowlevellock.c
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/arm/lowlevellock.c
@@ -23,6 +23,9 @@
 #include <tls.h>
 
 void
+#ifndef IS_IN_libpthread
+weak_function
+#endif
 __lll_lock_wait_private (int *futex)
 {
   do
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c b/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c
@@ -26,6 +26,9 @@
 
 
 void
+#ifndef IS_IN_libpthread
+weak_function
+#endif
 __lll_lock_wait_private (int *futex)
 {
   if (*futex == 2)
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c b/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/mq_notify.c
@@ -111,7 +111,7 @@ notification_function (void *arg)
 
 
 /* Helper thread.  */
-static void *
+static attribute_noreturn void *
 helper_thread (void *arg)
 {
   while (1)
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c b/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/timer_routines.c
@@ -69,7 +69,7 @@ timer_sigev_thread (void *arg)
 
 
 /* Helper function to support starting threads for SIGEV_THREAD.  */
-static void *
+static attribute_noreturn void *
 timer_helper_thread (void *arg)
 {
   /* Wait for the SIGTIMER signal, allowing the setXid signal, and
diff --git a/libpthread/nptl/unwind.c b/libpthread/nptl/unwind.c
--- a/libpthread/nptl/unwind.c
+++ b/libpthread/nptl/unwind.c
@@ -99,7 +99,7 @@ unwind_stop (int version, _Unwind_Action actions,
 }
 
 
-static void
+static attribute_noreturn void
 unwind_cleanup (_Unwind_Reason_Code reason, struct _Unwind_Exception *exc)
 {
   /* When we get here a C++ catch block didn't rethrow the object.  We
@@ -115,7 +115,7 @@ unwind_cleanup (_Unwind_Reason_Code reason, struct _Unwind_Exception *exc)
 
 
 void
-attribute_protected
+/*does not apply due to hidden_proto(): attribute_protected*/
 __cleanup_fct_attribute __attribute ((noreturn))
 #if !defined SHARED && !defined IS_IN_libpthread
 weak_function
-- 
